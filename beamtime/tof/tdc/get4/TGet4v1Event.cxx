/* Generated by Together */

#include "TGet4v1Event.h"

// ROOT headers
#include "Riostream.h"
#include "TString.h"

#include <iostream>

using std::cout;
using std::endl;

/*
 * Conversion of definitions to constants:
 *
MAX_ROC               get4v10::kiMaxRoc
MAX_GET4              get4v10::kiMaxGet4
MAX_GET4_PER_ROC      get4v10::kiMaxGet4Roc
MAX_AUX               get4v10::kiMaxAux
MAX_SYNC              get4v10::kiMaxSync
GET4_PRINT            get4v10::kiGet4MessPr
GET4_EPOCH_CYCLE_SIZE get4v10::kulGet4EpochCycleSz
MAIN_EPOCH_CYCLE_SIZE get4v10::kulMainEpochCycleSz
MAIN_CLK_SYNC_SIZE    get4v10::kiSyncCycleSzMain
GET4_SYNC_CYCLE_SIZE  get4v10::kiSyncCycleSzGet4
MAX_DATA_TRIGG        get4v10::kiMaxNbDataTriggs
MAX_SEC_TRIG          get4v10::kiMaxNbSecTriggCh

NB_BIN_GET4_FTS       get4tdc::kiFineTime
GET4_BIN_SIZE_IN_PS   get4tdc::kdBinSize
GET4_EPOCH_IN_BINS    get4tdc::kiEpochInBins
GET4_EPOCH_IN_PS      get4tdc::kdEpochInPs

psubevt->GetSubcrate()  fcSubCrate
psubevt->GetControl()   fcControl
psubevt->GetDlen()      uLength ???
psubevt->GetDataField() pMbsData

GetTriggerNumber()      Not available (TCBMBeamtimeProc method)
GetEventNumber()        Not available (TCBMBeamtimeProc method)
*/

Bool_t TGet4v1MessageExtended::RocOrder( const TGet4v1MessageExtended &messageToCompare) const
{
   /*
    * TODO: update with 32bit
    */
   if( uRocEpochCycle < messageToCompare.GetRocCycle() )      // messageToCompare in next Cycle
      return kTRUE;
   else if( uRocEpochCycle > messageToCompare.GetRocCycle() ) // messageToCompare in prev Cycle
      return kFALSE;
   else if( uRocEpoch < messageToCompare.GetRocEpoch() )      // messageToCompare in next Epoch
      return kTRUE;
   else if( uRocEpoch > messageToCompare.GetRocEpoch() )      // messageToCompare in prev Epoch
      return kFALSE;
   else  // Same cycle and same epoch!
   {
      UInt_t typ1 = fxMessage.getMessageType();
      UInt_t typ2 = (messageToCompare.GetRocMessage()).getMessageType();
      if( typ1 == roc::MSG_SYS && typ2 == roc::MSG_SYS)       // Both External synch messages
      {
         if( fxMessage.getField(23,12) <= (messageToCompare.GetRocMessage()).getField(23,12) )
            return kTRUE;
         else return kFALSE;
      }
      else if( typ1 == roc::MSG_SYS )                        // Only this message is Ext Synch
      {
         if( ((fxMessage.getField(23,12))<<7) <= (messageToCompare.GetRocMessage()).getGet4Ts() )
            return kTRUE;
         else return kFALSE;
      }
      else if(  typ2 == roc::MSG_SYS)                        // Only messageToCompare is Ext Synch
      {
         if( fxMessage.getGet4Ts() <= (((messageToCompare.GetRocMessage()).getField(23,12))<<7) )
            return kTRUE;
         else return kFALSE;
      }
      else                                                   // Both are data messages
      {
         if( fxMessage.getGet4Ts() <= (messageToCompare.GetRocMessage()).getGet4Ts() )
            return kTRUE;
         else return kFALSE;
      }
   }
}

Double_t TGet4v1MessageExtended::RocSpacing( const TGet4v1MessageExtended &messageToCompare) const
{
   /*
    * TODO: update with 32bit
    */
   UInt_t typ1 = fxMessage.getMessageType();
   UInt_t typ2 = (messageToCompare.GetRocMessage()).getMessageType();
   if( roc::MSG_GET4 != typ1 || roc::MSG_GET4 != typ2 ) // not a hit info
      return -1;
   // distance between two messages in bin multiplied by 0.05 ns.
   double dSpacing = get4tdc::kdBinSize * (double) ( (double) (messageToCompare.GetRocMessage()).getGet4Ts() -
                  (double)fxMessage.getGet4Ts() );
   // When messages are not in the same epoch
   // the time  has to be corrected
   if ( uRocEpoch != messageToCompare.GetRocEpoch() )
   {
      if( uRocEpochCycle != messageToCompare.GetRocCycle() )
      {
         dSpacing += get4tdc::kdEpochInPs * (double) ( (double)messageToCompare.GetRocEpoch() -
                                          (double)uRocEpoch +
                                          (double)get4v10::kulGet4EpochCycleSz * (double) ( (double)messageToCompare.GetRocCycle() -
                                          (double)uRocEpochCycle )  );
      }
      else
      {
         dSpacing += get4tdc::kdEpochInPs * (double) ( (double)messageToCompare.GetRocEpoch() -
                                       (double)uRocEpoch );
      }
   }
   // returns time in ps.
   return dSpacing;
}

void TGet4v1MessageExtended::Print( unsigned kind ) const
{
   if( roc::MSG_SYS == fxMessage.getMessageType() )
   {
      UChar_t ucSysMesType = fxMessage.getSysMesType();
      if( get4v10::SYSMSG_GET4V1_32BIT_0  <= ucSysMesType &&
          get4v10::SYSMSG_GET4V1_32BIT_15 >= ucSysMesType   )
      {
         Print32Bit( kind );
      } // case SYSMSG_GET4V1_32BIT + channel!
         else fxMessage.printData( kind, uRocEpoch + get4v10::kulGet4EpochCycleSz*uRocEpochCycle );
   }
      else fxMessage.printData( kind, uRocEpoch + get4v10::kulGet4EpochCycleSz*uRocEpochCycle );

}
void TGet4v1MessageExtended::Print32Bit( unsigned kind  ) const
{

   TString sPrintout ="";
   ULong64_t data = ((ULong64_t)fxMessage.getField( 48, 16 ) )<<48 |
                    ((ULong64_t)fxMessage.getField( 32, 16 ) )<<32 |
                    ((ULong64_t)fxMessage.getField( 16, 16 ) )<<16 |
                    ((ULong64_t)fxMessage.getField(  0, 16 ) );

   if( kind & roc::msg_print_Hex )
   {
      UChar_t* arr = (uint8_t*) &data;
      sPrintout  += Form("%02X:%02X:%02X:%02X:%02X:%02X ",
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]);
   } // if( kind & msg_print_Hex )

   if( kind & roc::msg_print_Prefix )
   {
      sPrintout  += Form( "Msg:%u Roc:%u ", fxMessage.getMessageType(), fxMessage.getRocNumber());
   } // if( kind & msg_print_Prefix)
   if (kind & roc::msg_print_Human)
   {
      Double_t timeInSec = fxMessage.getMsgFullTimeD(fuFulltime >> 14)/1.e9; // <--- to be change !!!!!
      sPrintout += Form( "SysType:%2x Data:%8x @%17.11f : ", fxMessage.getSysMesType(), fxMessage.getSysMesData(), timeInSec);
   } // if( kind & msg_print_Human )
      else sPrintout += Form( "SysType:%2x Data:%8x : ", fxMessage.getSysMesType(), fxMessage.getSysMesData());

   UInt_t get4_32b_type  = getFieldBE(fxMessage, 46, 2);  //(dataBE>>46) & 0x3;
   switch(get4_32b_type)
   {
      case 0: // epoch message
      {
         UInt_t get4_32b_ep_epoch = getFieldBE(fxMessage, 17,24);  //(dataBE>>17)  & 0xFFFFFF;
         UInt_t get4_32b_ep_sync  = getBitBE(fxMessage, 16);       //(dataBE>>16)  & 0x000001;
         sPrintout += Form( "Get4 V1 32 bits, type:0x%02x => Epoch %08d Sync: %1d",
               get4_32b_type, get4_32b_ep_epoch, get4_32b_ep_sync );
         break;
      }
      case 1: // slow control message
      {
         UInt_t get4_32b_sl_data = getFieldBE(fxMessage, 16, 24); //(dataBE>>16) & 0xFFFFFF;
         UInt_t get4_32b_sl_type = getFieldBE(fxMessage, 40, 2);  //(dataBE>>40) & 0x3;
         UInt_t get4_32b_sl_edge = getBitBE(fxMessage, 42);       //(dataBE>>42) & 0x1;
         UInt_t get4_32b_sl_chan = getFieldBE(fxMessage, 43, 2);  //(dataBE>>43) & 0x3;
         sPrintout += Form("Get4 V1 32 bits, type:0x%02x => Slow control Chan:%01d Edge:%01d Type:%01x Data:0x%06x",
               get4_32b_type, get4_32b_sl_chan, get4_32b_sl_edge, get4_32b_sl_type, get4_32b_sl_data );
         break;
      }
      case 2: // error event
      {
         UInt_t get4_32b_er_code = getFieldBE(fxMessage, 16,7); //(dataBE>>16)  & 0x7f;
         UInt_t get4_32b_er_chan = getFieldBE(fxMessage, 42,2); //(dataBE>>42)  & 0x3;
         UInt_t get4_32b_er_edge = getBitBE(fxMessage, 44);     //(dataBE>>44)  & 0x1;
         sPrintout += Form("Get4 V1 32 bits, type:0x%02x => Error 0x%02x Channel %1d Edge %1d",
               get4_32b_type, get4_32b_er_code, get4_32b_er_chan, get4_32b_er_edge );
         break;
      }
      case 3: // data event
      {
         UInt_t get4_32b_dat_tot  = getFieldBE(fxMessage, 16,  8); //(dataBE>>16) & 0xff;
         UInt_t get4_32b_dat_ft   = getFieldBE(fxMessage, 24,  7); //(dataBE>>24) & 0x7f;
         UInt_t get4_32b_dat_ts   = getFieldBE(fxMessage, 31,12);  //(dataBE>>31) & 0xfff;
         UInt_t get4_32b_dat_chan = getFieldBE(fxMessage, 43, 2);  //(dataBE>>43) & 0x3;
         UInt_t get4_32b_dat_dll  = getBitBE(fxMessage, 45);       //(dataBE>>45) & 0x1;
         sPrintout += Form("Get4 V1 32 bits, type:0x%02x => Data Dll %1d Channel %1d Ts:0x%04d Ft:0x%03d Tot:0x%03d",
               get4_32b_type, get4_32b_dat_dll, get4_32b_dat_chan, get4_32b_dat_ts,
               get4_32b_dat_ft, get4_32b_dat_tot);
         break;
      }
      default:
         sPrintout += Form("Get4 V1 32 bits, type:0x%02x ", get4_32b_type );
      break;
   } // switch(get4_32b_type)
   cout<<sPrintout<<endl;
}

/*****************************************************************************/
/* Get4 v1.0 hit */
Get4v1Hit::Get4v1Hit() : 
   TObject(),
   fbIs32Bit(kFALSE),
   fTimeMessage(),
   fbTimeSet(kFALSE),
   fTotMessage(),
   fbTotSet(kFALSE),
   fdTot(0.)
{ 
   Clear(); 
}
void  Get4v1Hit::Clear( Option_t *t )
{
   fbTimeSet = kFALSE;
   fbTotSet  = kFALSE;
   fdTot     = 0.0;
   fbIs32Bit = kFALSE;
}
void Get4v1Hit::SetFullHit24Bits( TGet4v1MessageExtended& mesTime, TGet4v1MessageExtended& mesTot)
{
   if( kFALSE == mesTime.Is32Bit() && kFALSE == mesTot.Is32Bit() )
   {
      /* TODO
       * Check on compatibility Time with Tot
       */
      fTimeMessage = mesTime;
      fTotMessage = mesTot;
      fbTimeSet = kTRUE;
      fbTotSet  = kTRUE;
      fbIs32Bit = kFALSE;
      CalculateTot();
   } // if( kFALSE == mesTime.Is32Bit() && kFALSE == mesTot.Is32Bit() )
}
void Get4v1Hit::SetFullHit32Bits( TGet4v1MessageExtended& mesHit, Double_t d32bTotRange )
{
   if( kTRUE == mesHit.Is32Bit() )
   {
      fTimeMessage = mesHit;
      fbTimeSet = kTRUE;
      fbTotSet  = kTRUE;
      fbIs32Bit = kTRUE;
      CalculateTot( d32bTotRange );
   } // if( mesHit.Is32Bit() )
}
void Get4v1Hit::SetTime24Bits( TGet4v1MessageExtended& mesTime )
{
   if( kFALSE == mesTime.Is32Bit() )
   {
      fTimeMessage = mesTime;
      fbTimeSet = kTRUE;
      fbIs32Bit = kFALSE;
      /* TODO
       * Check on compatibility Time with Tot
       */
      if( kTRUE == IsComplete() )
         CalculateTot();
   } // if( kFALSE == mesTime.Is32Bit() && kFALSE == mesTot.Is32Bit() )
}
void Get4v1Hit::SetTot24Bits(  TGet4v1MessageExtended& mesTot )
{
   if(  kFALSE == mesTot.Is32Bit() )
   {
      fTotMessage = mesTot;
      fbTotSet  = kTRUE;
      fbIs32Bit = kFALSE;
      /* TODO
       * Check on compatibility Time with Tot
       */
      if( kTRUE == IsComplete() )
         CalculateTot();
   } // if( kFALSE == mesTot.Is32Bit() )
}
void Get4v1Hit::CalculateTot( Double_t d32bTotRange )
{
   if( kTRUE == fbIs32Bit )
      fdTot = ((Double_t)fTimeMessage.getGet4V10R32HitTot() ) * (d32bTotRange/255.0);
      else fdTot = fTimeMessage.RocSpacing( fTotMessage);
}
Double_t Get4v1Hit::GetHitTime()
{
   /*
    * TODO: Epoch borders!!!
    */
   if( kTRUE == fbIs32Bit )
      return get4tdc::kdBinSize * fTimeMessage.getGet4V10R32HitTimeBin();
      else return get4tdc::kdBinSize * (fTimeMessage.GetRocMessage()).getGet4Ts();
}
Int_t Get4v1Hit::GetHitLeadingFTS()
{
   if( kTRUE == fbIs32Bit )
      return (Int_t)(fTimeMessage.getGet4V10R32HitFt());
      else return (Int_t)( ( (fTimeMessage.GetRocMessage()).getGet4Ts() )%get4tdc::kiFineTime );
}
Int_t Get4v1Hit::GetHitTrailingFTS()
{
   if( kTRUE == fbIs32Bit )
      return 0;
      else return (Int_t)( ( (fTotMessage.GetRocMessage()).getGet4Ts() )%get4tdc::kiFineTime );
}
Double_t Get4v1Hit::GetTimeDiff( Get4v1Hit& hitToCompare )
{
   if( kTRUE == fbIs32Bit &&
         kTRUE == hitToCompare.Is32Bit() )
   {
      // Both 32 bits
      /*
       * TODO: update RocSpacing, this is just a temp solution, not sure of resolution!!!
       * or use GetHitTime with epoch border check!!!!
       */
      return (hitToCompare.GetHitFullTimeD() - GetHitFullTimeD())*1000.0;
   }
   else if( kTRUE == fbIs32Bit )
      return -1000000.0; // Not both the same => crazy ?!?
   else if( kTRUE == hitToCompare.Is32Bit() )
      return 1000000.0; // Not both the same => crazy ?!?
   else // Both 24 bits
      return fTimeMessage.RocSpacing( (hitToCompare.GetTimeMessage()) );
}
/*****************************************************************************/
/* Get4 v1.0 TDC */
Get4v1Tdc::~Get4v1Tdc()
{
   Clear();
}
/*
Get4v1Tdc::Get4v1Tdc(const Get4v1Tdc& src) : TObject()
{
   for( Int_t iChan = 0; iChan < get4v10::kuNbChan; iChan++)
      fHits[iChan] = src.fHits[iChan];
}
Get4v1Tdc & Get4v1Tdc::operator=(const Get4v1Tdc& src)
{
   // TObject copy attempt....
   TObject* ptrObj1 = this;
   TObject* ptrObj2 = &src;
   *ptrObj1 = *ptrObj2;

   for( Int_t iChan = 0; iChan < get4v10::kuNbChan; iChan++)
      this.fHits[iChan] = src.fHits[iChan];
   return *this;
}
*/
void  Get4v1Tdc::Clear(Option_t *t )
{
   for(UInt_t uChannelIndex = 0; uChannelIndex < get4v10::kuNbChan; uChannelIndex++)
   {
      for(UInt_t uHitIndex = 0; uHitIndex < fHits[uChannelIndex].size(); uHitIndex++)
         fHits[uChannelIndex][uHitIndex].Clear();
      fHits[uChannelIndex].clear();
   }
}
UInt_t  Get4v1Tdc::Size()
{
   UInt_t uSize = 0;
   for(UInt_t uChannelIndex = 0; uChannelIndex < get4v10::kuNbChan; uChannelIndex++)
      uSize += fHits[uChannelIndex].size();
   return uSize;
}

/*****************************************************************************/
/* Real Event */
Get4v1Event::Get4v1Event() : 
   TObject(),
   fuMbsEventNumber(0),
   fuEventNbInsideMbsEvt(0),
   fuGlobalEventNumber(0),
   fbMbsSyncedEvent(kFALSE),
   fuSyncEventNumber(0),
   fbDataTriggered(kFALSE),
   fuTriggerIndex(0)
{ 
   Clear(); 
}
Get4v1Event::~Get4v1Event()
{
   Clear();
}
void  Get4v1Event::Clear( Option_t *t )
{
  // all members should be cleared.
   for(UInt_t uGet4Index = 0; uGet4Index < get4v10::kiMaxGet4; uGet4Index++)
      fGet4Boards[uGet4Index].Clear( );

   for(UInt_t uRocIndex = 0; uRocIndex < get4v10::kiMaxRoc; uRocIndex++)
   {
      fPureRocMessages[uRocIndex].clear();
      fdTriggerFullTime[uRocIndex] = 0.0;
   } // for(UInt_t uRocIndex = 0; uRocIndex < get4v10::kiMaxGet4; uRocIndex++)

   fuMbsEventNumber      = 0;
   fuEventNbInsideMbsEvt = 0;
   fuGlobalEventNumber   = 0;
   fbMbsSyncedEvent      = kFALSE;
   fuSyncEventNumber     = 0;
}
UInt_t  Get4v1Event::Size()
{
   UInt_t uSize = 0;
   for(UInt_t uGet4Index = 0; uGet4Index < get4v10::kiMaxGet4; uGet4Index++)
      uSize += fGet4Boards[uGet4Index].Size( );
   return uSize;
}
Bool_t  Get4v1Event::IsEmpty()
{
   Bool_t bEmpty = kTRUE;
   for(UInt_t uGet4Index = 0; uGet4Index < get4v10::kiMaxGet4; uGet4Index++)
      bEmpty &= ( 0 == fGet4Boards[uGet4Index].Size( ) );
   return bEmpty;
}
Bool_t  Get4v1Event::HasTrigger()
{
   Bool_t bTrigger = kFALSE;
   for(UInt_t uRocIndex = 0; uRocIndex < get4v10::kiMaxRoc; uRocIndex++)
      if( 0 < fdTriggerFullTime[uRocIndex] )
      {
         bTrigger = kTRUE;
         break;
      }
   return bTrigger;
}

///////////////////////////////

