/** @file readTsa.C
 ** @author Florian Uhlig <f.uhlig@gsi.de>
 ** @since August 2014
 ** @date 23.01.2015
 **
 ** Adapted to GET4 v1.23 unpacker in 32b mode by P.-A. Loizeau
 ** ROOT macro to read tsa files which have been generated by a flib board and convert the data
 ** into cbmroot format.
 ** Uses CbmFlibFileSource as source task.
 **
 ** 02/06/2015: new macro from only monitoring
 */


void monitor_file_get4( Int_t nEvents = -1,
      Int_t iUnpackMode = 1, 
      TString inFolder = "data/",
      TString inFile = "get4Test")
{

//   FairRunOnline* run = new FairRunOnline();
   CbmRunOnline* run = new CbmRunOnline();

   // Create pattern for histo output file name
   TString sHistoFile = "./" + inFile + Form("_%1u", iUnpackMode);

   // Create pattern for calib output file name
   TString sCalibFile = inFile + Form("_%1u", iUnpackMode);


  // --- Specify output file name (this is just an example)
  TString outFile = "data/" + inFile + Form("_%1u", iUnpackMode) + ".root";

  // Create input filename
  TString inFileFull = inFolder + inFile + ".tsa";

  // --- Set log output levels
//  FairLogger::GetLogger()->SetLogScreenLevel("WARNING");
  FairLogger::GetLogger()->SetLogScreenLevel("INFO");
//  FairLogger::GetLogger()->SetLogScreenLevel("DEBUG");
//  FairLogger::GetLogger()->SetLogScreenLevel("DEBUG2");
  FairLogger::GetLogger()->SetLogVerbosityLevel("LOW");

  // --- Set debug level
  gDebug = 0;

  std::cout << std::endl;
  std::cout << ">>> readTsa:  input file is " << inFileFull  << std::endl;
  std::cout << ">>> readTsa: output file is " << outFile << std::endl;
  std::cout << ">>> readTsa:  histo file is " << sHistoFile << std::endl;
  std::cout << ">>> readTsa:  Calib file is " << sCalibFile << std::endl;

  // ========================================================================
  // ========================================================================

  std::cout << std::endl;
  std::cout << ">>> readTsa: Initialising..." << std::endl;

  // GET4 Monitor
  CbmGet4FastMonitor* get4_monitor = new CbmGet4FastMonitor();
  get4_monitor->SetRocNb(      2); // Min 1
  get4_monitor->SetGet4Nb(    88); // Min 1 64 + 24
  get4_monitor->SetMsOverlapTs(0); // Min 1
  get4_monitor->SetMode( iUnpackMode ); // 0 = debug, 1 = moni
//  get4_monitor->SetVerbose( kTRUE );
     // Disable unconnected chips
  for( UInt_t uChipIndex =  0; uChipIndex < 16; uChipIndex++)
     get4_monitor->SetActiveGet4( uChipIndex, kFALSE );
  for( UInt_t uChipIndex = 24; uChipIndex < 72; uChipIndex++)
     get4_monitor->SetActiveGet4( uChipIndex, kFALSE );
  for( UInt_t uChipIndex = 80; uChipIndex < 88; uChipIndex++)
     get4_monitor->SetActiveGet4( uChipIndex, kFALSE );

//  get4_monitor->SetBinSizeEvoHistos(  10.0 );
  get4_monitor->SetBinSizeEvoHistos(   1.0 );
//  get4_monitor->SetBinSizeEvoHistos(   0.1 );
  get4_monitor->SetLengthEvoHistos( 1200.0 );
  get4_monitor->SetMicroSliceLength( 16384*8*(1e-9) ); // s, From to 01/03 15:00

//  get4_monitor->SetPulserMode( kFALSE ); // kTRUE = ON, kFALSE = OFF (default is ON)
  get4_monitor->SetPulserMode( ); // kTRUE = ON, kFALSE = OFF (default is ON)
  get4_monitor->SetPulserFee( 2 ); // 1 value (default is 0)
//  get4_monitor->SetPulserFeeB( 2 ); // 1 value (default is 0)

//CHannel 1 against CHannel 1 of 16 ASICs
/*  get4_monitor->SetPulserChans(  64, 68, 72, 76,
                                 80, 84, 88, 92,
                                288,292,296,300,
                                304,308,312,316); // 1-16 values (default is 0-15)
*/ 
//CHannel 1-16 B1
    get4_monitor->SetPulserChans(  64, 65, 66, 67,
                                   68, 69, 70, 71,
                                   72, 73, 74, 75, 
                                   76, 77, 78, 79); // 

//CHannel 17-32 B1
/*    get4_monitor->SetPulserChans(  80, 81, 82, 83,
                                   84, 85, 86, 87,
                                   88, 89, 90, 91,
                                   92, 93, 94, 95); // 
*/
//CHannel 1-16 B2  
/* get4_monitor->SetPulserChans(   288, 289, 290, 291, 
                                 292, 293, 294, 295, 
                                 296, 297, 298, 299,
                                 300, 301, 302, 303); // 
*/
//CHannel 17-32 B2  
/* get4_monitor->SetPulserChans(   304, 305, 306, 307, 
                                 308, 309, 310, 311, 
                                 312, 313, 314, 315, 
                                 316, 317, 318, 319); // 
*/
  get4_monitor->SetOldReadoutSupp();
//  get4_monitor->SetMaxCoincDist(200000.0); // ps
  get4_monitor->SetMaxCoincDist(5000.0); // ps
  get4_monitor->SetHistoFilename( sHistoFile + "_unpack.hst.root");
  /*
  get4_monitor->SetCalibOutOn();
  get4_monitor->SetCalibOutFolder( "./data/");
  get4_monitor->SetCalibFilename( sCalibFile);
  */
  get4_monitor->SetMaxDtMultiHit( 12800.0 ); // ps


  // --- Source task
  CbmFlibFileSourceNew* source = new CbmFlibFileSourceNew();
  std::cout << ">>> readTsa: Adding input file..." << std::endl;
  source->SetFileName(inFileFull);
  std::cout << ">>> readTsa: Adding unpacker..." << std::endl;
  source->AddUnpacker(get4_monitor, 0x60);
  std::cout << ">>> readTsa: Source OK..." << std::endl;

  // --- Run
  run->SetSource(source);
  run->SetOutputFile(outFile);
//  run->SetAutoFinish(kFALSE);
  run->SetAsync();

  run->Init();

  // --- Start run
  TStopwatch timer;
  timer.Start();
//  std::cout << ">>> Start run from the command line by calling Run(<events>)" << std::endl;
  run->Run(nEvents, 0); // run until end of input file

  get4_monitor->Finish(); // Should be called first as histo owned by analysis file :-(
  run->Finish();
  timer.Stop();

  // --- End-of-run info
  Double_t rtime = timer.RealTime();
  Double_t ctime = timer.CpuTime();
  std::cout << std::endl << std::endl;
  std::cout << ">>> readTsa: Macro finished successfully." << std::endl;
  std::cout << ">>> readTsa: Output file is " << outFile << std::endl;
  std::cout << ">>> readTsa: Real time " << rtime << " s, CPU time "
               << ctime << " s" << std::endl;
  std::cout << std::endl;

  /// --- Screen output for automatic tests
  std::cout << " Test passed" << std::endl;
  std::cout << " All ok " << std::endl;
}
