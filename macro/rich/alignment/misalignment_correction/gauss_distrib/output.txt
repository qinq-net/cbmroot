
Processing run_sim.C...
G__BaseDict dictionary payload:4184:19: error: cannot initialize a parameter of type 'TObject *' with an lvalue of type 'FairGenerator *'
    fGenList->Add(generator);
                  ^~~~~~~~~
/data/ROOT6/FairSoft/may16/tools/root/build_for_fair/include/root/TObjArray.h:75:34: note: passing argument to parameter 'obj' here
   void             Add(TObject *obj) { AddLast(obj); }
                                 ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairPrimaryGenerator with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      if (fSorter!= 0) { delete fSorter; }
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairLogger;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
    /**ctor*/
    FairRootManager();
    /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString BrName);
    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);
    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:
    /**private methods*/
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );
    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);


    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRootManager*  fgInstance;
#else
    static                FairRootManager*  fgInstance;
#endif

    /**Branch id for this run */
    Int_t                               fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,11) // Root IO manager
};


#endif //FAIR_ROOT_MANAGER_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRun* fRunInstance;
#else
    static                FairRun* fRunInstance;
#endif
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    const char*              fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager, 
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();
                                               
  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //! 
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //! 

    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
#if !defined(__CINT__)
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
#else
    static                FairRunSim*  fginstance;//!              /** Singleton Instance */
#endif
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#endif

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the
        subtasks. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action after each event. To be implemented in the derived class **/
    virtual void Finish() { };

    //  /** Action after each event. To be implemented in the derived class **/
    //  virtual void FinishTask() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,3);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    void SetGenerateHtml(Bool_t flag, const char* histFileName, Int_t refreshRate);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    TFolder*    fFolder;       //!
    Bool_t      fGenerateHtml; //!
    TString     fHistFileName; //!
    Int_t       fRefreshRate;  //!
    Int_t       fNevents;      //!

    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    void WriteObjects();
    void GenerateHtml();

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairLinkManager* fgInstance;
#else
    static                FairLinkManager* fgInstance;
#endif

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairStack header file                    -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone  Flag for tracking
     *@param parentID  Index of mother particle
     *@param pdgCode   Particle type (PDG encoding)
     *@param px,py,pz  Momentum components at start vertex [GeV]
     *@param e         Total energy at start vertex [GeV]
     *@param vx,vy,vz  Coordinates of start vertex [cm]
     *@param time      Start time of track [s]
     *@param polx,poly,polz Polarisation vector
     *@param proc      Production mechanism (VMC encoding)
     *@param ntr       Track number (filled by the stack)
     *@param weight    Particle weight
     *@param is        Generation status code (whatever that means)
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is);

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/

    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID);


    /** Virtual method PopNextTrack.
     ** Gets next particle for tracking from the stack.
     *@param  iTrack  index of popped track
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopNextTrack(Int_t& iTrack);


    /** Virtual method PopPrimaryForTracking.
     ** Gets primary particle by index for tracking from stack.
     *@param  iPrim   index of primary particle
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopPrimaryForTracking(Int_t iPrim);


    /** Add a TParticle to the fParticles array **/
    void AddParticle(TParticle* part);


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray();


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0);


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset();


    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register();


    /** Output to screen
     **@param iVerbose: 0=events summary, 1=track info
     **/
    virtual void Print(Option_t* option="") const;


    /** Modifiers  **/
    virtual void SetCurrentTrack(Int_t iTrack);

    /** Accessors **/
    virtual Int_t GetNtrack() const;   // Total number of tracks
    virtual Int_t GetNprimary() const; // Number of primaries
    virtual TParticle* GetCurrentTrack() const;
    virtual Int_t GetCurrentTrackNumber() const;
    virtual Int_t GetCurrentParentTrackNumber() const;
    virtual TParticle* GetParticle(Int_t) const { return NULL; }

    virtual TClonesArray* GetListOfParticles() { return NULL; } 

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*            fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)


};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    virtual void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init worker run (used in MT mode only) */
    virtual void InitForWorker() const;

    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    void RegisterStack();

    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairRootManager*      fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!

    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include "Riosfwd.h"   // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0.);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register();
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for ostream, cout

class FairLink : public TObject
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    virtual ~FairLink();

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = file;
      fEntry = entry;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = -1;
      fEntry = -1;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    Int_t GetFile() const {return fFile;}
    Int_t GetEntry() const {return fEntry;}
    Int_t GetType() const {return fType;}
    Int_t GetIndex() const {return fIndex;}
    Float_t GetWeight() const {return fWeight;}

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}

    virtual void PrintLinkInfo(std::ostream& out = std::cout) const;

    virtual bool operator==(const FairLink& link) const {
      if ((fFile == link.GetFile() || link.GetFile() == -1) && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    virtual bool operator<(const FairLink& link) const {
	if (fFile != -1 && link.GetFile() != -1){
		if (fFile < link.GetFile()) 		return true;
		else if (link.GetFile() < fFile) 	return false;
	}
	if (fEntry != -1 && link.GetEntry() != -1){
		if(fEntry < link.GetEntry())		return true;
		else if (link.GetEntry() < fEntry)	return false;
	}
	if (fType < link.GetType())				return true;
	else if (link.GetType() < fType)		return false;
	if (fIndex < link.GetIndex())			return true;
	else if (link.GetIndex() < fIndex)		return false;

	return false;
//      if (fFile != -1 && fFile < link.GetFile()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1) && fEntry < link.GetEntry()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType < link.GetType()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex < link.GetIndex()) {
//        return true;
//      } else {
//        return false;
//      }
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDef(FairLink, 3);


  private:
    Int_t fFile;
    Int_t fEntry;
    Int_t fType;
    Int_t fIndex;
    Float_t fWeight;

};

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    #ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;

    #endif // for BOOST serialization
    
    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    virtual FairMultiLinkedData* 		GetPointerToLinks() const {	return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:

    Int_t fVerbose; //!
    Bool_t fInsertHistory; //!
    FairMultiLinkedData* fLink;

    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!
    FairLogger* fLogger;

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#ifndef __CINT__ // for BOOST serialization
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp();
    /** Accessors **/
    virtual Double_t GetTimeStamp()             const { return fTimeStamp; };
    virtual Double_t GetTimeStampError()     const { return fTimeStampError;};
    virtual FairLink GetEntryNr() const {return fEntryNr;}
    /** Modifiers **/
    virtual void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    virtual void SetTimeStampError(Double_t t) {fTimeStampError = t;}
    virtual void SetEntryNr(FairLink entry) {fEntryNr = entry;}
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }


    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};


    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */
    FairLink fEntryNr; //!  indicates where the data is stored in the branch

    ClassDef(FairTimeStamp,3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc

#if ROOT_VERSION_CODE < 333824

#ifndef ROOT_TVirtualMagField
#define ROOT_TVirtualMagField
// copied from ROOT for backward compatibility with ROOT versions before 5.24
#include "TNamed.h"

class TVirtualMagField : public TNamed
{
  public:
    TVirtualMagField()                 : TNamed() {}
    TVirtualMagField(const char* name) : TNamed(name,"") {}
    virtual ~TVirtualMagField() {}
    virtual void Field(const Double_t* x, Double_t* B) = 0;
    ClassDef(TVirtualMagField, 1)              // Abstract base field class
};
ClassImp(TVirtualMagField)
#endif


#else

#include "TVirtualMagField.h"

#endif

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    void OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName) {return;}
    virtual void   ReadBranchEvent(const char* BrName, Int_t Event) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__BaseDict dictionary payload:1715:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairTimeStamp.h:11:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData_Interface.h:13:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairLink.h:97:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
                         ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairLink.h:97:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
                         ^
In file included from G__BaseDict dictionary payload:1715:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairTimeStamp.h:11:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData_Interface.h:14:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData.h:94:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
                         ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData.h:94:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
                         ^
In file included from G__BaseDict dictionary payload:1715:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairTimeStamp.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData_Interface.h:73:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
                         ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairMultiLinkedData_Interface.h:73:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
                         ^
In file included from G__BaseDict dictionary payload:1715:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairTimeStamp.h:72:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
                         ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairTimeStamp.h:72:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
                         ^
G__BaseDict dictionary payload:4184:19: error: cannot initialize a parameter of type 'TObject *' with an lvalue of type 'FairGenerator *'
    fGenList->Add(generator);
                  ^~~~~~~~~
/data/ROOT6/FairSoft/may16/tools/root/build_for_fair/include/root/TObjArray.h:75:34: note: passing argument to parameter 'obj' here
   void             Add(TObject *obj) { AddLast(obj); }
                                 ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:22:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1.h:35:3: error: typedef redefinition with different types ('struct s_ve10_1' vs 'struct s_ve10_1')
} s_ve10_1;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1.h:35:3: note: previous definition is here
} s_ve10_1;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:23:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1.h:35:3: error: typedef redefinition with different types ('struct s_ves10_1' vs 'struct s_ves10_1')
} s_ves10_1 ;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1.h:35:3: note: previous definition is here
} s_ves10_1 ;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:24:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe.h:31:3: error: typedef redefinition with different types ('struct s_evhe' vs 'struct s_evhe')
} s_evhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe.h:31:3: note: previous definition is here
} s_evhe;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:25:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe.h:48:3: error: typedef redefinition with different types ('struct s_bufhe' vs 'struct s_bufhe')
} s_bufhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe.h:48:3: note: previous definition is here
} s_bufhe;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:43:3: error: typedef redefinition with different types ('struct s_taghe' vs 'struct s_taghe')
} s_taghe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:43:3: note: previous definition is here
} s_taghe;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:48:3: error: typedef redefinition with different types ('struct s_tag' vs 'struct s_tag')
} s_tag;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:48:3: note: previous definition is here
} s_tag;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:89:3: error: typedef redefinition with different types ('struct s_evt_channel' vs 'struct s_evt_channel')
} s_evt_channel;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:89:3: note: previous definition is here
} s_evt_channel;
  ^
In file included from G__BaseDict dictionary payload:7354:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe_swap.h:12:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe.h:74:3: error: typedef redefinition with different types ('struct s_filhe' vs 'struct s_filhe')
} s_filhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe.h:74:3: note: previous definition is here
} s_filhe;
  ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairGenerator with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      if (fSorter!= 0) { delete fSorter; }
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairLogger;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
    /**ctor*/
    FairRootManager();
    /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString BrName);
    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);
    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:
    /**private methods*/
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );
    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);


    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRootManager*  fgInstance;
#else
    static                FairRootManager*  fgInstance;
#endif

    /**Branch id for this run */
    Int_t                               fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,11) // Root IO manager
};


#endif //FAIR_ROOT_MANAGER_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRun* fRunInstance;
#else
    static                FairRun* fRunInstance;
#endif
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    const char*              fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager, 
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();
                                               
  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //! 
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //! 

    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
#if !defined(__CINT__)
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
#else
    static                FairRunSim*  fginstance;//!              /** Singleton Instance */
#endif
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#endif

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the
        subtasks. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action after each event. To be implemented in the derived class **/
    virtual void Finish() { };

    //  /** Action after each event. To be implemented in the derived class **/
    //  virtual void FinishTask() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,3);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    void SetGenerateHtml(Bool_t flag, const char* histFileName, Int_t refreshRate);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    TFolder*    fFolder;       //!
    Bool_t      fGenerateHtml; //!
    TString     fHistFileName; //!
    Int_t       fRefreshRate;  //!
    Int_t       fNevents;      //!

    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    void WriteObjects();
    void GenerateHtml();

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairLinkManager* fgInstance;
#else
    static                FairLinkManager* fgInstance;
#endif

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairStack header file                    -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone  Flag for tracking
     *@param parentID  Index of mother particle
     *@param pdgCode   Particle type (PDG encoding)
     *@param px,py,pz  Momentum components at start vertex [GeV]
     *@param e         Total energy at start vertex [GeV]
     *@param vx,vy,vz  Coordinates of start vertex [cm]
     *@param time      Start time of track [s]
     *@param polx,poly,polz Polarisation vector
     *@param proc      Production mechanism (VMC encoding)
     *@param ntr       Track number (filled by the stack)
     *@param weight    Particle weight
     *@param is        Generation status code (whatever that means)
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is);

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/

    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID);


    /** Virtual method PopNextTrack.
     ** Gets next particle for tracking from the stack.
     *@param  iTrack  index of popped track
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopNextTrack(Int_t& iTrack);


    /** Virtual method PopPrimaryForTracking.
     ** Gets primary particle by index for tracking from stack.
     *@param  iPrim   index of primary particle
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopPrimaryForTracking(Int_t iPrim);


    /** Add a TParticle to the fParticles array **/
    void AddParticle(TParticle* part);


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray();


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0);


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset();


    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register();


    /** Output to screen
     **@param iVerbose: 0=events summary, 1=track info
     **/
    virtual void Print(Option_t* option="") const;


    /** Modifiers  **/
    virtual void SetCurrentTrack(Int_t iTrack);

    /** Accessors **/
    virtual Int_t GetNtrack() const;   // Total number of tracks
    virtual Int_t GetNprimary() const; // Number of primaries
    virtual TParticle* GetCurrentTrack() const;
    virtual Int_t GetCurrentTrackNumber() const;
    virtual Int_t GetCurrentParentTrackNumber() const;
    virtual TParticle* GetParticle(Int_t) const { return NULL; }

    virtual TClonesArray* GetListOfParticles() { return NULL; } 

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*            fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)


};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    virtual void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init worker run (used in MT mode only) */
    virtual void InitForWorker() const;

    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    void RegisterStack();

    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairRootManager*      fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!

    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include "Riosfwd.h"   // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0.);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register();
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for ostream, cout

class FairLink : public TObject
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    virtual ~FairLink();

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = file;
      fEntry = entry;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = -1;
      fEntry = -1;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    Int_t GetFile() const {return fFile;}
    Int_t GetEntry() const {return fEntry;}
    Int_t GetType() const {return fType;}
    Int_t GetIndex() const {return fIndex;}
    Float_t GetWeight() const {return fWeight;}

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}

    virtual void PrintLinkInfo(std::ostream& out = std::cout) const;

    virtual bool operator==(const FairLink& link) const {
      if ((fFile == link.GetFile() || link.GetFile() == -1) && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    virtual bool operator<(const FairLink& link) const {
	if (fFile != -1 && link.GetFile() != -1){
		if (fFile < link.GetFile()) 		return true;
		else if (link.GetFile() < fFile) 	return false;
	}
	if (fEntry != -1 && link.GetEntry() != -1){
		if(fEntry < link.GetEntry())		return true;
		else if (link.GetEntry() < fEntry)	return false;
	}
	if (fType < link.GetType())				return true;
	else if (link.GetType() < fType)		return false;
	if (fIndex < link.GetIndex())			return true;
	else if (link.GetIndex() < fIndex)		return false;

	return false;
//      if (fFile != -1 && fFile < link.GetFile()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1) && fEntry < link.GetEntry()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType < link.GetType()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex < link.GetIndex()) {
//        return true;
//      } else {
//        return false;
//      }
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDef(FairLink, 3);


  private:
    Int_t fFile;
    Int_t fEntry;
    Int_t fType;
    Int_t fIndex;
    Float_t fWeight;

};

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    #ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;

    #endif // for BOOST serialization
    
    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    virtual FairMultiLinkedData* 		GetPointerToLinks() const {	return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:

    Int_t fVerbose; //!
    Bool_t fInsertHistory; //!
    FairMultiLinkedData* fLink;

    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!
    FairLogger* fLogger;

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#ifndef __CINT__ // for BOOST serialization
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp();
    /** Accessors **/
    virtual Double_t GetTimeStamp()             const { return fTimeStamp; };
    virtual Double_t GetTimeStampError()     const { return fTimeStampError;};
    virtual FairLink GetEntryNr() const {return fEntryNr;}
    /** Modifiers **/
    virtual void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    virtual void SetTimeStampError(Double_t t) {fTimeStampError = t;}
    virtual void SetEntryNr(FairLink entry) {fEntryNr = entry;}
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }


    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};


    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */
    FairLink fEntryNr; //!  indicates where the data is stored in the branch

    ClassDef(FairTimeStamp,3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc

#if ROOT_VERSION_CODE < 333824

#ifndef ROOT_TVirtualMagField
#define ROOT_TVirtualMagField
// copied from ROOT for backward compatibility with ROOT versions before 5.24
#include "TNamed.h"

class TVirtualMagField : public TNamed
{
  public:
    TVirtualMagField()                 : TNamed() {}
    TVirtualMagField(const char* name) : TNamed(name,"") {}
    virtual ~TVirtualMagField() {}
    virtual void Field(const Double_t* x, Double_t* B) = 0;
    ClassDef(TVirtualMagField, 1)              // Abstract base field class
};
ClassImp(TVirtualMagField)
#endif


#else

#include "TVirtualMagField.h"

#endif

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    void OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName) {return;}
    virtual void   ReadBranchEvent(const char* BrName, Int_t Event) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_9:1:
In file included from /data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:5:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairBoxGenerator.h:37:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:73:28: error: expected parameter declarator
    ClassDef(FairGenerator,1);
                           ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:73:28: error: expected ')'
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:73:13: note: to match this '('
    ClassDef(FairGenerator,1);
            ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:73:5: error: C++ requires a type specifier for all declarations
    ClassDef(FairGenerator,1);
    ^
In file included from input_line_9:1:
In file included from /data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:5:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairBoxGenerator.h:144:31: error: expected parameter declarator
    ClassDef(FairBoxGenerator,3);
                              ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairBoxGenerator.h:144:31: error: expected ')'
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairBoxGenerator.h:144:13: note: to match this '('
    ClassDef(FairBoxGenerator,3);
            ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairBoxGenerator.h:144:5: error: C++ requires a type specifier for all declarations
    ClassDef(FairBoxGenerator,3);
    ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairGeoVector with content:

#line 1 "G__GeoBaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOASSEMBLY_H
#define FAIRGEOASSEMBLY_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoAssembly::Class, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoAssembly : public FairGeoBasicShape
{
  public:
    FairGeoAssembly();
    ~FairGeoAssembly();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream* pFile,FairGeoVolume* volu);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);

    ClassDef(FairGeoAssembly,0) // class for geometry shape ASSEMBLY
};

#endif  /* !FAIRGEOASSEMBLY_H */


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOCONE_H
#define FAIRGEOCONE_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoCone::Class, Bool_t, etc

#include <iosfwd>                       // for fstream


class FairGeoTransform;
class FairGeoVolume;
class TArrayD;
/**
 * class for geometry shape CONE
 * @author ilse koenig
 */
class FairGeoCone : public FairGeoBasicShape
{
  public:
    FairGeoCone();
    ~FairGeoCone();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoCone,0) //
};

#endif  /* !FAIRGEOCONE_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOCONS_H
#define FAIRGEOCONS_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoCons::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;
/**
 * class for geometry shape CONS
 * @author ilse koenig
 */
class FairGeoCons : public FairGeoBasicShape
{
  public:
    FairGeoCons();
    ~FairGeoCons();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoCons,0) //
};

#endif  /* !FAIRGEOCONS_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOELTU_H
#define FAIRGEOELTU_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoEltu::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

/**
 * class for geometry shape ELTU
 * @author Ilse  koenig
 */
class FairGeoEltu : public FairGeoBasicShape
{
  public:
    FairGeoEltu();
    ~FairGeoEltu();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoEltu,0) //
};

#endif  /* !FAIRGEOELTU_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOBUILDER_H
#define FAIRGEOBUILDER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, etc

class FairGeoNode;
class FairGeoMedium;

/**
 * abstract base class for geometry builders
 * @author ilse koenig
 */
class FairGeoBuilder : public TNamed
{
  protected:
    Int_t nRot;  // number of defined rotations
    Int_t nMed;  // number of defined media

    FairGeoBuilder();
    FairGeoBuilder(const char* name,const char* title);
  public:
    virtual ~FairGeoBuilder() {}
    virtual Bool_t createNode(FairGeoNode*, Int_t hadFormat =0)=0;
    virtual Int_t createMedium(FairGeoMedium*)=0;
    virtual void finalize() {}
    inline const Int_t& GetNMedia() const { return nMed; }
    inline void SetNMedia(const Int_t& nmed) { nMed = nmed; }
    ClassDef(FairGeoBuilder,0)
};

#endif /* !FAIRGEOBUILDER_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOINTERFACE_H
#define FAIRGEOINTERFACE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, kFALSE, Int_t, etc
#include "TString.h"                    // for TString

class FairGeoIo;
class FairGeoSet;
class FairGeoMedia;
class FairGeoShapes;
class FairGeoBuilder;
class TObjArray;
class TList;

enum EHGeoDetPart {
  kFairGeoCave   =  0,
  kFairGeoPipe   =  1,
  kFairGeoTarget =  2,
  kFairGeoMagnet =  3,
  kFairGeoRich   =  4,
  kFairGeoSts    =  5,
  kFairGeoTrd    =  6,
  kFairGeoTof    =  7,
  kFairGeoEcal   =  8
};


/**
 * Class to manage geometry for simulations
 * @author Ilse koenig
 * @author M. Al-Turany
 */
class FairGeoInterface : public TObject
{
    FairGeoIo*      fileInput;   /** ASCII file I/O */
    FairGeoIo*      oraInput;    /** Oracle input */
    FairGeoIo*      output;      /** Oracle output */
    Int_t         nSets;       /** number of geometry sets (detector parts) */
    Int_t         nActualSets; /** number of set in actual geometry */
    TObjArray*    sets;        /** array of geometry  sets */
    FairGeoMedia*   media;       /** list of media */
    FairGeoShapes*  shapes;      /** list of shapes */
    TList*        masterNodes; /** list of mother nodes used by several sets */
    TString       setupFile;   /** file with detector setups (subsets) */
    FairGeoBuilder* geoBuilder;  /** actually used geometry builder */
  public:
    FairGeoInterface();
    ~FairGeoInterface();
    void setOracleInput(FairGeoIo* p) {oraInput=p;}
    void setOutput(FairGeoIo* p) {output=p;}
    void setGeomBuilder(FairGeoBuilder* p) {geoBuilder=p;}
    FairGeoIo* getFileInput() { return fileInput; }
    FairGeoIo* getOraInput() { return oraInput; }
    FairGeoIo* getOutput() { return output; }
    FairGeoShapes* getShapes() { return shapes; }
    FairGeoMedia* getMedia() { return media; }
    TList* getMasterNodes() { return masterNodes; }
    void addInputFile(const char*);
    void addGeoModule(FairGeoSet*);
    void setMediaFile(const char* file);
    FairGeoSet* findSet(const char*);
    Bool_t readSet(FairGeoSet*);
    Bool_t writeSet(FairGeoSet*);
    Bool_t writeSet(FairGeoSet*,const char*);
    Bool_t createSet(FairGeoSet*);
    void deleteSet(FairGeoSet* pSet);
    Bool_t readMedia();
    Bool_t writeMedia();
    Bool_t writeMedia(const char*);
    Bool_t readAll();
    Bool_t writeAll();
    Bool_t createAll(Bool_t withCleanup=kFALSE);
    Bool_t createGeometry(Bool_t withCleanup=kFALSE);
    Bool_t readGeomConfig(const char*);
    void addSetupFile(const char* f) {setupFile=f;}
    Bool_t readSetupFile();
    void print();
    void SetNoOfSets(Int_t n) {nSets=n;} //
  private:
    FairGeoInterface(const FairGeoInterface&);
    FairGeoInterface& operator=(const FairGeoInterface&);

    FairGeoIo* connectInput(const char*);
    Bool_t connectOutput(const char*);

    ClassDef(FairGeoInterface,0) //
};

#endif /* !FAIRGEOINTERFACE_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOIO_H
#define FAIRGEOIO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, FairGeoIo::Class, etc

class FairGeoMedia;
class FairGeoSet;
class FairGeoInterface;

/**
 * Abstract base class for geometry I/O
 * @author Ilse Koenig
 */
class FairGeoIo : public TObject
{
  public:
    virtual Bool_t open(const char*,const Text_t* status="in")=0;
    virtual void close()=0;
    virtual void print()=0;
    virtual Bool_t isOpen()=0;
    virtual Bool_t isWritable()=0;
    virtual Bool_t read(FairGeoMedia*)=0;
    virtual Bool_t read(FairGeoSet*,FairGeoMedia*)=0;
    virtual Bool_t write(FairGeoMedia*)=0;
    virtual Bool_t write(FairGeoSet*)=0;
    virtual Bool_t readGeomConfig(FairGeoInterface*)=0;
    virtual Bool_t setSimulRefRun(const char*)=0;
    virtual Bool_t setHistoryDate(const char*)=0;
  private:
    ClassDef(FairGeoIo,0) //
};

#endif  /* !FAIRGEOIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/***************************************************************************
                          FairGeoLoader.h  -  description
                             -------------------
    begin                : Thu Jun 17 2004
    copyright            : (C) 2004 by turany
    email                : m.al-turany@gsi.de
 ***************************************************************************/


#ifndef FairGeoLOADER_H
#define FairGeoLOADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for FairGeoLoader::Class, etc

class FairGeoInterface;
class FairGeoBuilder;
/**New Geometry Loader, this loader handel the Hades geometry description
 * @author Ilse koenig
 * @author M. Al-Turany*/

class FairGeoLoader : public TNamed
{
  public:
    FairGeoLoader(const char* Name, const char* title);
    FairGeoLoader();
    virtual ~FairGeoLoader();
    FairGeoInterface* getGeoInterface() {return fInterface;}
    FairGeoBuilder*   getGeoBuilder() {return   fGeoBuilder; }
    /** static access method*/
    static FairGeoLoader* Instance();

  private:
    FairGeoLoader(const FairGeoLoader&);
    FairGeoLoader& operator=(const FairGeoLoader&);
    static FairGeoLoader*  fgInstance;//!  /**Singleton instance*/
    FairGeoInterface*    fInterface; //!  /** Hades Geometry Interface*/
    FairGeoBuilder*    fGeoBuilder; //!   /**Geometry builder*/
    ClassDef(FairGeoLoader,1)

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOMATRIX_H
#define FAIRGEOMATRIX_H

#include "TObject.h"                    // for TObject

#include "FairGeoVector.h"              // for FairGeoVector

#include "Rtypes.h"                     // for Double_t, etc

/**
 * @author Ilse koenig
 */
class FairGeoMatrix : public TObject
{
  protected:
    Double_t fM[9];
  public:
    FairGeoMatrix(void);
    ~FairGeoMatrix(void);
    Double_t& operator()(Int_t i,Int_t j) { return fM[i*3+j]; }
    Double_t det(void);
    FairGeoVector operator*(FairGeoVector& v);
    FairGeoMatrix& operator/=(Double_t d);
    ClassDef(FairGeoMatrix,0)
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOMEDIA_H
#define FAIRGEOMEDIA_H

#include "TNamed.h"                     // for TNamed

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoMedia::Class, etc
#include "TString.h"                    // for TString

#include <iosfwd>                       // for fstream

class FairGeoMedium;
class TList;

/**
 * Class for materials and media
 * @author Ilse koenig
 */
class FairGeoMedia : public TNamed
{
  private:
    TList* media;           /** list of media */
    TString inputFile;      /** name of input file or Oracle */
    TString author;         /** author of the media version */
    TString description;    /** description of the version */
  public:
    FairGeoMedia();
    ~FairGeoMedia();
    void setInputFile(const char* file) { inputFile=file; }
    const char* getInputFile() { return inputFile; }
    void addMedium(FairGeoMedium* m);
    FairGeoMedium* getMedium(const char*);
    TList* getListOfMedia() {return media;}
    void read(std::fstream&);
    void print();
    void list();
    void write(std::fstream&);
    void setAuthor(TString& s) {author=s;}
    void setDescription(TString& s) {description=s;}
    TString& getAuthor() {return author;}
    TString& getDescription() {return description;}
  private:
    FairGeoMedia(const FairGeoMedia&);
    FairGeoMedia& operator=(const FairGeoMedia&);

    ClassDef(FairGeoMedia,0) //
};

#endif /* !FAIRGEOMEDIA_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOMEDIUM_H
#define FAIRGEOMEDIUM_H

#include "TNamed.h"                     // for TNamed

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Double_t, Int_t, Bool_t, etc

#include <fstream>                      // for fstream

/**
 * Class for tracking medium
 * @author ilse koenig
 */
class FairGeoMedium  : public TNamed
{
  private:
    Int_t     medId;       /** Unique number for the material and the medium */
    Int_t     autoflag;    /** Flag for default values of madfld .. minstep*/
    Int_t     nComponents; /** Number of material components */
    Int_t     weightFac;   /** Factor for weights (1: relative w., -1: w. by number of atoms)*/
    Double_t* ca;         //[nComponents] /** Atomic weights for the components*/
    Double_t* cz;         //[nComponents] /** Atomic numbers for the components*/
    Double_t* cw;         //[nComponents] /** Weights of the components in a mixture*/
    Double_t  density;     /** Density in g cm(**-3)*/
    Double_t  radLen;      /** Radiation lenght*/
    Int_t     sensFlag;    /** Sensitivity flag*/
    Int_t     fldFlag;     /** Field flag*/
    Double_t  fld;         /** Maximum field value in kilogauss*/
    Double_t  epsil;       /** Boundary crossing precision*/
    Double_t  madfld;      /** Maximum angular deviation due to field*/
    Double_t  maxstep;     /** Maximum step permitted*/
    Double_t  maxde;       /** Maximum fractional energy loss*/
    Double_t  minstep;     /** Minimum value for step*/
    Int_t     npckov;      /** Number of optical parameters for Cerenkov*/
    Double_t* ppckov;     //[npckov]  /** Photon momentum*/
    Double_t* absco;      //[npckov] /** Absoption length*/
    Double_t* effic;      //[npckov] /** Detection efficiency*/
    Double_t* rindex;     //[npckov] /** Refraction index*/
  public:
    FairGeoMedium(const char* name="");
    FairGeoMedium& operator=(const FairGeoMedium&) {return *this;}
    ~FairGeoMedium();
    void setMediumIndex(Int_t i) {medId=i;}
    Int_t getMediumIndex() {return medId;}
    void setAutoFlag(Int_t i) {autoflag=i;}
    Int_t getAutoFlag() {return autoflag;}
    void setNComponents(Int_t);
    Int_t getNComponents() {return nComponents;}
    Bool_t setComponent(Int_t,Double_t,Double_t,Double_t w=1.);
    void getComponent(Int_t,Double_t*);
    Int_t getWeightFac() {return weightFac;}
    void setDensity(Double_t d) {density=d;}
    Double_t getDensity() {return density;}
    void setRadiationLength(Double_t l) {radLen=l;}
    Double_t getRadiationLength() {return radLen;}
    void setNpckov(Int_t);
    Int_t getNpckov() {return npckov;}
    Bool_t setCerenkovPar(Int_t,Double_t,Double_t,Double_t,Double_t);
    void getCerenkovPar(Int_t,Double_t*);
    void setMediumPar(Int_t,Int_t,Double_t,Double_t,Double_t maxDeviation=-1.,
                      Double_t maxStep=-1.,Double_t maxDE=-1.,
                      Double_t minStepDouble_t=-1.);
    void getMediumPar(Double_t*);
    inline Bool_t isSensitive();
    Int_t getSensitivityFlag() { return sensFlag;}
    Int_t getFieldFlag() {return fldFlag;}
    Double_t getField() {return fld;}
    Double_t getEpsil() {return epsil;}
    void read(std::fstream&, Int_t autoflag );
    void print();
    void write (std::fstream&);
    Bool_t calcRadiationLength();
  private:
    FairGeoMedium(const FairGeoMedium&);
    //TODO: correct copy constructor for FairGeoMedium
    //    FairGeoMedium& operator=(const FairGeoMedium&);

    ClassDef(FairGeoMedium,1) //
};

inline Bool_t FairGeoMedium::isSensitive()
{
  if (sensFlag) { return kTRUE; }
  else { return kFALSE; }
}

#endif /* !FAIRGEOMEDIUM_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEONODE_H
#define FAIRGEONODE_H

#include "FairGeoVolume.h"              // for FairGeoVolume

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape
#include "FairGeoMedium.h"              // for FairGeoMedium
#include "FairGeoTransform.h"           // for FairGeoTransform

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Bool_t, FairGeoNode::Class, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

#include <iosfwd>                       // for fstream

class FairGeoVector;
class TArrayD;
class TGeoVolume;
class TList;

enum EFairGeoNodeType {
  kFairGeoElement = 0,
  kFairGeoKeepin  = 1,
  kFairGeoModule  = 2,
  kFairGeoTopNode = 3,
  kFairGeoRefNode = 4
};


/**
 * basic geometry parameters of a volume
 * @author Ilse koenig
 */
class FairGeoNode : public FairGeoVolume
{
  private:
    FairGeoNode(const FairGeoNode&);
    FairGeoNode& operator=(const FairGeoNode&);
  protected:
    Bool_t active;                /** in/out flag for creation */
    FairGeoTransform center;        /** position of the GEANT/ROOT center */
    EFairGeoNodeType volumeType;    /** type of volume */
    Bool_t created;               /** Flag set kTRUE after creation of volume */
    FairGeoNode* copyNode;         /** pointer to the reference volume for a copy */
    TGeoVolume* rootVolume;       /** pointer to the ROOT node */
    FairGeoBasicShape*  pShape;       /** pointer to the shape */
    FairGeoNode* pMother;        //!    /** pointer to the mother volume */
    FairGeoMedium* medium;           /** pointer to medium */
    FairGeoTransform* labTransform; /** Transformation to the LAB system */
    TObjArray* fDaughterList; /** List of daughter Nodes  */
    //const char*   fTruncName;    //
    TString   fTruncName;
  public:
    FairGeoNode();
    FairGeoNode(FairGeoNode&);
    virtual ~FairGeoNode();
    void AddDaughter(FairGeoNode* fNode) {fDaughterList->AddLast(fNode);}
    TObjArray* GetListOfDaughters() {return fDaughterList;}
    EFairGeoNodeType getVolumeType() { return volumeType; }
    Bool_t isTopNode() { return static_cast<Bool_t>((volumeType == kFairGeoTopNode));}
    Bool_t isRefNode() { return static_cast<Bool_t>((volumeType == kFairGeoRefNode));}
    Bool_t isKeepin()  { return static_cast<Bool_t>((volumeType == kFairGeoKeepin));}
    Bool_t isModule()  { return static_cast<Bool_t>((volumeType == kFairGeoModule));}
    Int_t getCopyNo();
    FairGeoBasicShape* getShapePointer() { return pShape; }
    FairGeoNode* getMotherNode() {return pMother;}
    FairGeoMedium* getMedium() {return medium;}
    Bool_t isActive() {return active;}
    FairGeoTransform& getCenterPosition() {return center;}
    TArrayD* getParameters();
    FairGeoTransform* getPosition();
    FairGeoTransform* getLabTransform();
    FairGeoNode* getCopyNode() {return copyNode;}
    TGeoVolume* getRootVolume() {return rootVolume;}
    TList* getTree();
    Bool_t isSensitive();
    Bool_t isCreated() {return created;}
    void setCreated() {created=kTRUE;}
    void setName(const Text_t* s);
    void setVolumeType(EFairGeoNodeType t) {volumeType=t;}
    void setVolumePar(FairGeoNode&);
    void setShape(FairGeoBasicShape* s);
    void setMother(FairGeoNode* s);
    void setMedium(FairGeoMedium* med) {medium=med; }
    void setActive(Bool_t a=kTRUE) {active=a;}
    void setCenterPosition(const FairGeoTransform& t) {center=t;}
    void setCopyNode(FairGeoNode* p) {copyNode=p;}
    void setRootVolume(TGeoVolume* p) {rootVolume=p;}
    FairGeoTransform* calcLabTransform();
    void setLabTransform(FairGeoTransform&);
    Bool_t calcModuleTransform(FairGeoTransform&);
    Bool_t calcRefPos(FairGeoVector&);
    void clear();
    void print();
    Bool_t write(std::fstream&);
    Int_t compare(FairGeoNode&);


    void setTruncName( const char* aName ) { fTruncName = aName;}
    const char* getTruncName() {
      if (fTruncName.Length()>0) { return fTruncName.Data(); }
      else { return GetName(); }
    }

    ClassDef(FairGeoNode,1) //
};

// -------------------- inlines --------------------------

inline void FairGeoNode::setName(const Text_t* s)
{
  // Sets the name of the volume
  fName=s;
  fName.ToUpper();
}

inline void FairGeoNode::setShape(FairGeoBasicShape* s)
{
  // Sets the shape of the volume
  if (s) {
    pShape=s;
    shape=pShape->GetName();
  }
}

inline void FairGeoNode::setMother(FairGeoNode* moth)
{
  // Sets the mother of the volume
  if (moth) {
    pMother=moth;
    mother=pMother->GetName();
    pMother->AddDaughter(this);
  }
}

inline Bool_t FairGeoNode::isSensitive()
{
  if (medium) { return medium->isSensitive(); }
  else { return kFALSE; }
}

#endif /* !FAIRGEONODE_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOOLDASCIIIO_H
#define FAIRGEOOLDASCIIIO_H

#include "FairGeoIo.h"                  // for FairGeoIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

class FairGeoInterface;
class FairGeoMedia;
class FairGeoNode;
class FairGeoSet;

/**
 * Class for geometry I/O from ASCII file in FAIR format
 * @author Ilse koenig
 */
class FairGeoOldAsciiIo: public FairGeoIo
{
    TString  filename;
    TString  filedir;
    Bool_t   writable;
    std::fstream* file;
  public:
    FairGeoOldAsciiIo();
    ~FairGeoOldAsciiIo();
    void setDirectory(const char* fDir) {filedir=fDir;}
    const char* getDirectory() {return filedir.Data();}
    const char* getFilename() {return filename.Data();}
    Bool_t open(const char*,const Text_t* status="in");
    Bool_t isOpen();
    Bool_t isWritable();
    void close();
    void print();
    Bool_t read(FairGeoMedia*) {return kFALSE;}
    Bool_t read(FairGeoSet*,FairGeoMedia*);
    Bool_t write(FairGeoMedia*) {return kFALSE;}
    Bool_t write(FairGeoSet*) {return kFALSE;}
    Bool_t readGeomConfig(FairGeoInterface*) {return kFALSE;}
    Bool_t readDetectorSetup(FairGeoInterface*) {return kFALSE;}
    Bool_t setSimulRefRun(const char*) {return kTRUE;}
    Bool_t setHistoryDate(const char*) {return kTRUE;}
  private:
    Bool_t calculateShapePoints(Double_t*,FairGeoNode*);
    FairGeoOldAsciiIo(const FairGeoOldAsciiIo&);
    FairGeoOldAsciiIo& operator=(const FairGeoOldAsciiIo&);

    ClassDef(FairGeoOldAsciiIo,0) //
};

#endif  /* !FAIRGEOOLDASCIIIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOPCON_H
#define FAIRGEOPCON_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

/**
 * class for geometry shape PCON
 * @author Ilse koenig
 */
class FairGeoPcon : public FairGeoBasicShape
{
  public:
    FairGeoPcon();
    ~FairGeoPcon();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoPcon,0) //
};

#endif  /* !FAIRGEOPCON_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOPGON_H
#define FAIRGEOPGON_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

/**
 * class for geometry shape PGON
 * @author Ilse koenig
 */
class FairGeoPgon : public FairGeoBasicShape
{
  public:
    FairGeoPgon();
    ~FairGeoPgon();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoPgon,0) //
};

#endif  /* !FAIRGEOPGON_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOROOTBUILDER_H
#define FAIRGEOROOTBUILDER_H

#include "FairGeoBuilder.h"             // for FairGeoBuilder

#include "Rtypes.h"                     // for FairGeoRootBuilder::Class, etc

class FairGeoMedium;
class FairGeoNode;
class TGeoManager;

/**
 * class to create geometry in ROOT
 * @author M. Al-Turany
 */
class FairGeoRootBuilder : public FairGeoBuilder
{
  private:
    FairGeoRootBuilder(const FairGeoRootBuilder&);
    FairGeoRootBuilder& operator=(const FairGeoRootBuilder&);
  protected:
    TGeoManager* geoManager; // ROOT geometry manager
  public:
    FairGeoRootBuilder();
    FairGeoRootBuilder(const char*,const char*);
    ~FairGeoRootBuilder() {}
    void setGeoManager(TGeoManager* me) {geoManager=me;}
    Bool_t createNode(FairGeoNode*, Int_t hadFormat=0);
    Int_t createMedium(FairGeoMedium*);
    void finalize();
    void checkOverlaps(Double_t ovlp=0.0001);
    ClassDef(FairGeoRootBuilder,0) //
};

#endif /* !FAIRGEOROOTBUILDER_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOROTATION_H
#define FAIRGEOROTATION_H

#include "TObject.h"                    // for TObject

#include "FairGeoVector.h"              // for FairGeoVector

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, Int_t, Bool_t, etc

#include <iostream>                     // for operator<<, cout, ostream, etc

class TRotMatrix;

/**
 * rotation matrix
 * @author Ilse koenig
 */
class FairGeoRotation : public TObject
{
  protected:
    Double_t rot[9];
  public:
    inline FairGeoRotation();
    inline FairGeoRotation(const FairGeoRotation&);
    inline FairGeoRotation(const Double_t*);
    FairGeoRotation(const Double_t,const Double_t,const Double_t);
    ~FairGeoRotation() {}
    inline void setMatrix(const Double_t*);
    inline void setMatrix(const Float_t*);
    void setEulerAngles(const Double_t,const Double_t,const Double_t);
    inline void setElement(const Double_t,const Int_t);
    inline Double_t operator () (Int_t) const;
    inline FairGeoRotation& operator = (const FairGeoRotation&);
    inline Bool_t operator == (const FairGeoRotation&);
    inline Bool_t operator != (const FairGeoRotation&);
    inline FairGeoVector operator * (const FairGeoVector&) const;
    inline FairGeoRotation operator * (const FairGeoRotation&) const;
    inline FairGeoRotation& operator *= (const FairGeoRotation&);
    inline FairGeoRotation& transform(const FairGeoRotation&);
    inline Bool_t isUnitMatrix();
    inline FairGeoRotation inverse() const;
    inline FairGeoRotation& invert();
    inline Double_t determinant() const;
    Double_t diff2(const FairGeoRotation&) const;
    inline Double_t getElement(Int_t i,Int_t j) const;
    inline void setUnitMatrix();
    inline void setZero();
    inline void print() const;
    TRotMatrix* createTRotMatrix(const Text_t* name="",const Text_t* title="");

    ClassDef(FairGeoRotation,1) //
};

// -------------------- inlines ---------------------------

inline FairGeoRotation::FairGeoRotation()
  :TObject()
{
  rot[0]=rot[4]=rot[8]=1.;
  rot[1]=rot[2]=rot[3]=rot[5]=rot[6]=rot[7]=0.;
}

inline Double_t FairGeoRotation::operator () (Int_t i) const
{
  if (i>=0 && i<9) { return rot[i]; }
  Error("operator()","bad index");
  return 0;
}

inline FairGeoRotation::FairGeoRotation(const FairGeoRotation& r)
  :TObject(r)
{
  for(Int_t i=0; i<9; i++) { rot[i]=r(i); }
}

inline FairGeoRotation::FairGeoRotation(const Double_t* a)
  :TObject()
{
  for(Int_t i=0; i<9; i++) { rot[i]=a[i]; }
}

inline void FairGeoRotation::setMatrix(const Double_t* a)
{
  for(Int_t i=0; i<9; i++) { rot[i]=a[i]; }
}

inline void FairGeoRotation::setMatrix(const Float_t* a)
{
  for(Int_t i=0; i<9; i++) { rot[i]=a[i]; }
}

inline void FairGeoRotation::setElement(const Double_t a, const Int_t i)
{
  if (i<9) { rot[i]=a; }
}

inline Double_t FairGeoRotation::getElement(Int_t i,Int_t j) const
{
  return rot[i*3+j];
}

inline FairGeoRotation& FairGeoRotation::operator = (const FairGeoRotation& r)
{
  for(Int_t i=0; i<9; i++) { rot[i]=r(i); }
  return *this;
}

inline Bool_t FairGeoRotation::operator == (const FairGeoRotation& r)
{
  Int_t i=0;
  while (i<9) {
    if (rot[i]!=r(i)) { return kFALSE; }
    i++;
  }
  return kTRUE;
}

inline Bool_t FairGeoRotation::operator != (const FairGeoRotation& r)
{
  Int_t i=0;
  while (i<9) {
    if (rot[i]!=r(i)) { return kTRUE; }
    i++;
  }
  return kFALSE;
}

inline FairGeoVector FairGeoRotation::operator * (const FairGeoVector& v) const
{
  return FairGeoVector(rot[0]*v(0)+rot[1]*v(1)+rot[2]*v(2),
                       rot[3]*v(0)+rot[4]*v(1)+rot[5]*v(2),
                       rot[6]*v(0)+rot[7]*v(1)+rot[8]*v(2));
}

inline FairGeoRotation FairGeoRotation::operator * (const FairGeoRotation& r) const
{
  Double_t a[9];
  for(Int_t kk=0; kk<9; kk++) { a[kk]=0; }
  for(Int_t i=0; i<3; i++) {
    for(Int_t j=0; j<3; j++) {
      Int_t n=3*i+j;
      for(Int_t k=0; k<3; k++) { a[n]+=rot[3*i+k]*r(3*k+j); }
    }
  }
  return FairGeoRotation(&a[0]);
}

inline FairGeoRotation& FairGeoRotation::operator *= (const FairGeoRotation& r)
{
  return *this=operator * (r);
}

inline   FairGeoRotation& FairGeoRotation::transform(const FairGeoRotation& r)
{
  return *this=r*(*this);
}

inline Bool_t FairGeoRotation::isUnitMatrix()
{
  return (rot[0]==1. && rot[1]==0. && rot[2]==0. &&
          rot[3]==0. && rot[4]==1. && rot[5]==0. &&
          rot[6]==0. && rot[7]==0. && rot[8]==1.)  ? kTRUE : kFALSE;
}

inline FairGeoRotation FairGeoRotation::inverse() const
{
  Double_t a[9];
  for(Int_t i=0; i<3; i++) {
    for(Int_t j=0; j<3; j++) { a[j+3*i]=rot[i+3*j]; }
  }
  return FairGeoRotation(a);
}

inline FairGeoRotation& FairGeoRotation::invert()
{
  return *this=inverse();
}

inline Double_t FairGeoRotation::determinant() const
{
  return rot[0]*(rot[4]*rot[8]-rot[7]*rot[5])
         -rot[3]*(rot[1]*rot[8]-rot[7]*rot[2])
         +rot[6]*(rot[1]*rot[5]-rot[4]*rot[2]);
}

inline void FairGeoRotation::setUnitMatrix()
{
  rot[0]=rot[4]=rot[8]=1.;
  rot[1]=rot[2]=rot[3]=rot[5]=rot[6]=rot[7]=0.;
}

inline void FairGeoRotation::setZero()
{
  for(Int_t i=0; i<9; i++) { rot[i]=0.; }
}

inline void FairGeoRotation::print() const
{
  for(Int_t i=0; i<9; i++) { std::cout<<rot[i]<<"  "; }
  std::cout<<'\n';
}

#endif /* !FAIRGEOROTATION_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOSET_H
#define FAIRGEOSET_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoNode.h"

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TList.h"                      // for TList
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

//class FairGeoNode;
class FairGeoShapes;
class FairGeoMedia;
class FairGeoBuilder;
class FairGeoTransform;
class TArrayI;

/**
 * Base class for geometry of detector parts
 * @author Ilse koenig
 */
class  FairGeoSet : public TNamed
{

  protected:
    Int_t hadesGeo;

    class FairGeoCopyNode : public TNamed
    {
      public:
        FairGeoNode* pNode;
        FairGeoCopyNode(const char* name,FairGeoNode* node)
          : TNamed(name,""), pNode(node) {}
        //          SetName(name);
        //
        //        }
        ~FairGeoCopyNode() {}
      private:
        FairGeoCopyNode(const FairGeoCopyNode&);
        FairGeoCopyNode& operator=(const FairGeoCopyNode&);

    };
    TList* volumes;         /** list of volumes */
    TList* masterNodes;     /** pointer to list of mother volumes from other detector parts*/
    Int_t maxSectors;       /** maximum number of sectors (-1 for detectors outside any sector)*/
    Int_t maxKeepinVolumes; /** maximum number of keepin volumes per sector*/
    Int_t maxModules;       /** maximum number of modules per sector*/
    TArrayI* modules;       /** Module's array.*/
    FairGeoShapes* pShapes;  /** pointer to the class FairGeoShapes*/
    TString geoFile;        /** name of geometry input file or Oracle*/
    TString author;         /** author of the media version*/
    TString description;    /** description of the version*/

    FairGeoSet();
    void readInout(std::fstream&);
    void readTransform(std::fstream&,FairGeoTransform&);
    Bool_t readVolumeParams(std::fstream&,FairGeoMedia*,FairGeoNode*,TList* l=0);
    Bool_t readKeepIn(std::fstream&,FairGeoMedia*,TString&);
    Bool_t readModule(std::fstream&,FairGeoMedia*,TString&,TString&,Bool_t a=kFALSE);
  public :
    virtual ~FairGeoSet();
    void setShapes(FairGeoShapes* s) {pShapes=s;}
    void setMasterNodes(TList* m) {masterNodes=m;}
    void setGeomFile(const char* filename) {geoFile=filename;}
    const char* getGeomFile() { return geoFile.Data(); }
    Int_t getMaxSectors(void) {return maxSectors;}
    Int_t getMaxModules(void) {return maxModules;}
    Int_t getMaxKeepinVolumes(void) {return maxKeepinVolumes;}
    void setModules(Int_t,Int_t*);
    Int_t* getModules(void);
    Int_t getModule(Int_t,Int_t);
    FairGeoNode* getVolume(const char* name) {return dynamic_cast<FairGeoNode*>(volumes->FindObject(name));}
    FairGeoNode* getMasterNode(const char* name) {return dynamic_cast<FairGeoNode*>(masterNodes->FindObject(name));}
    TList* getListOfVolumes() {return volumes;}
    FairGeoShapes* getShapes() {return pShapes;}
    void setAuthor(TString& s) {author=s;}
    void setDescription(TString& s) {description=s;}
    TString& getAuthor() {return author;}
    TString& getDescription() {return description;}
    virtual const char* getKeepinName(Int_t,Int_t) {return 0;}
    virtual const char* getModuleName(Int_t) {return 0;}
    virtual const char* getEleName(Int_t) {return 0;}
    virtual Int_t getSecNumInMod(const TString&) {return -1;}
    virtual Int_t getModNumInMod(const TString&) {return 0;}
    virtual Bool_t read(std::fstream&,FairGeoMedia*);
    virtual void addRefNodes() {}
    virtual void write(std::fstream&);
    virtual void print();
    virtual Bool_t create(FairGeoBuilder*);
    void compare(FairGeoSet&);
    ClassDef(FairGeoSet,0) //
  private:
    FairGeoSet(const FairGeoSet&);
    FairGeoSet& operator=(const FairGeoSet&);
};


#endif  /* !FAIRGEOSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOSHAPES_H
#define FAIRGEOSHAPES_H

#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoShapes::Class, etc
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

class FairGeoVolume;
class FairGeoBasicShape;
class TList;
/**
 * manager class for geometry shapes
 * @author Ilse koenig
 */
class  FairGeoShapes : public TObject
{
  private:
    FairGeoShapes(const FairGeoShapes&);
    FairGeoShapes& operator=(const FairGeoShapes&);
  protected:
    TList* shapes;  // list of already created shape classes
  public :
    FairGeoShapes();
    ~FairGeoShapes();
    FairGeoBasicShape* selectShape(FairGeoVolume*);
    FairGeoBasicShape* selectShape(const TString&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoShapes,0) //
};

#endif  /* !FAIRGEOSHAPES_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOSPHE_H
#define FAIRGEOSPHE_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

/**
 * class for geometry shape SPHE
 * @author Ilse koenig
 */
class FairGeoSphe : public FairGeoBasicShape
{
  public:
    FairGeoSphe();
    ~FairGeoSphe();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoSphe,0) //
};

#endif  /* !FAIRGEOSPHE_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTRANSFORM_H
#define FAIRGEOTRANSFORM_H

#include "TObject.h"                    // for TObject

#include "FairGeoRotation.h"            // for FairGeoRotation
#include "FairGeoVector.h"              // for FairGeoVector

#include "Rtypes.h"                     // for Double_t, etc

/**
 * basic geometry transformation class
 * @author Ilse koenig*/
class FairGeoTransform : public TObject
{
  protected:
    FairGeoRotation rot;   /** rotation matrix, describing the orientation*/
    FairGeoVector trans;   /** translation vector, describing the position*/
    FairGeoVector trans_cm;   /** translation vector, describing the position in cm*/
  public:
    FairGeoTransform();
    inline FairGeoTransform(const FairGeoTransform& t);
    ~FairGeoTransform() {}
    FairGeoTransform& operator=(const FairGeoTransform& t);
    const FairGeoRotation& getRotMatrix() const { return rot; }
    const FairGeoVector& getTransVector() const { return trans; }
    void setRotMatrix(const FairGeoRotation& r) { rot=r; }
    void setRotMatrix(const Double_t* a) { rot.setMatrix(a); }
    void setRotMatrix(const Float_t* a) { rot.setMatrix(a); }
    void setTransVector(const FairGeoVector& t) { trans=t; }
    void setTransVector(const Double_t* a) { trans.setVector(a); }
    void setTransVector(const Float_t* a) { trans.setVector(a); }
    FairGeoVector transFrom(const FairGeoVector& p) const;
    FairGeoVector transTo(const FairGeoVector& p) const;
    void transFrom(const FairGeoTransform&);
    void transTo(const FairGeoTransform&);
    void invert(void);
    void clear();
    void print();
    const FairGeoVector& getTranslation()   {
      const double fac = 10.;
      trans_cm=trans;
      return (trans_cm/=fac);
    }

    const FairGeoRotation& getRotation() const { return rot; }

    inline void setTransform(const FairGeoTransform& t);
    ClassDef(FairGeoTransform,1) //
};

inline FairGeoTransform::FairGeoTransform(const FairGeoTransform& t)
  : TObject(t),
    rot(t.getRotMatrix()),
    trans(t.getTransVector()),
    trans_cm(FairGeoVector(0,0,0))
{

}


inline void FairGeoTransform::setTransform(const FairGeoTransform& t)
{
  rot=t.getRotMatrix();
  trans=t.getTransVector();
}

#endif /* !FAIRGEOTRANSFORM_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTRAP_H
#define FAIRGEOTRAP_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "FairGeoRotation.h"            // for FairGeoRotation

#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoTrap : public FairGeoBasicShape
{
  private:
    FairGeoRotation intrinsicRot;
  public:
    FairGeoTrap();
    ~FairGeoTrap();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    ClassDef(FairGeoTrap,0) // class for geometry shape TRAP
};

#endif  /* !FAIRGEOTRAP_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTRD1_H
#define FAIRGEOTRD1_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "FairGeoRotation.h"            // for FairGeoRotation

#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoTrd1 : public FairGeoBasicShape
{
  private:
    FairGeoRotation intrinsicRot;
  public:
    FairGeoTrd1();
    ~FairGeoTrd1();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    ClassDef(FairGeoTrd1,0) // class for geometry shape TRD1
};

#endif  /* !FAIRGEOTRD1_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTUBE_H
#define FAIRGEOTUBE_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoTube : public FairGeoBasicShape
{
  public:
    FairGeoTube();
    ~FairGeoTube();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoTube,0) // class for geometry shape TUBE
};

#endif  /* !FAIRGEOTUBE_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTUBS_H
#define FAIRGEOTUBS_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoTubs : public FairGeoBasicShape
{
  public:
    FairGeoTubs();
    ~FairGeoTubs();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream*,FairGeoVolume*);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);
    ClassDef(FairGeoTubs,0) // class for geometry shape TUBS
};

#endif  /* !FAIRGEOTUBS_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOTORUS_H
#define FAIRGEOTORUS_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for FairGeoPcon::Class, Bool_t, etc

#include <iosfwd>                       // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoTorus : public FairGeoBasicShape
{
  public:
    FairGeoTorus();
    ~FairGeoTorus();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    Int_t readPoints(std::fstream* pFile,FairGeoVolume* volu);
    Bool_t writePoints(std::fstream*,FairGeoVolume*);
    void printPoints(FairGeoVolume* volu);

    ClassDef(FairGeoTorus,0) // class for geometry shape TORUS
};

#endif  /* !FAIRGEOTORUS_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOVECTOR_H
#define FAIRGEOVECTOR_H

#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream, istream
#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TMath.h"                      // for pow, floor, sqrt
#include "TMathBase.h"                  // for Abs

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, ostream, etc

class FairGeoVector : public TObject
{
  protected:
    Double_t x;
    Double_t y;
    Double_t z;
    inline void round(Double_t d,Int_t n);
  public:
    FairGeoVector(Double_t dx=0,Double_t dy=0,Double_t dz=0)
      : TObject(),x(dx),y(dy),z(dz) {}
    FairGeoVector(const FairGeoVector& v)
      : TObject(v),x(v.getX()), y(v.getY()), z(v.getZ()) {}
    ~FairGeoVector() {}
    Double_t& X() {return x;}
    Double_t& Y() {return y;}
    Double_t& Z() {return z;}
    Double_t getX() const {return x;}
    Double_t getY() const {return y;}
    Double_t getZ() const {return z;}

    Double_t getValues(Int_t i ) {
      if ( i<0 || i>2 ) {
        std::cout << " -E- Vector index  is 0 1 2 only ! " << std::endl;
      }
      if ( i == 0 ) { return x; }
      if ( i == 1 ) { return y; }
      if ( i == 2 ) { return z; }
      return -1;
    }

    void setXYZ(const Double_t xx,const Double_t yy,const Double_t zz) {
      x=xx;
      y=yy;
      z=zz;
    }
    void setX(const Double_t a) {x=a;}
    void setY(const Double_t a) {y=a;}
    void setZ(const Double_t a) {z=a;}
    inline void setVector(const Double_t* a);
    inline void setVector(const Float_t* a);
    inline Double_t operator() (const Int_t i) const;
    inline FairGeoVector operator - () const;
    inline FairGeoVector& operator = (const FairGeoVector& v);
    inline Bool_t operator == (const FairGeoVector& v) const;
    inline Bool_t operator != (const FairGeoVector& v) const;
    inline Bool_t operator < (const Double_t a);
    inline Bool_t operator <= (const Double_t a);
    inline Bool_t operator > (const Double_t a);
    inline Bool_t operator >= (const Double_t a);
    inline FairGeoVector& operator += (const Double_t a);
    inline FairGeoVector& operator -= (const Double_t a);
    inline FairGeoVector& operator *= (const Double_t a);
    inline FairGeoVector& operator /= (const Double_t a);
    inline FairGeoVector& operator += (const FairGeoVector& v);
    inline FairGeoVector& operator -= (const FairGeoVector& v);
    inline FairGeoVector operator + (const FairGeoVector& v) const;
    inline FairGeoVector operator - (const FairGeoVector& v) const;
    inline FairGeoVector& abs();
    inline Double_t scalarProduct(const FairGeoVector& v) const;
    inline FairGeoVector vectorProduct(const FairGeoVector& v) const;
    Double_t length() const {return sqrt(x*x+y*y+z*z);}
    void clear() {x=y=z=0.;}
    void print() const {printf("%10.3f%10.3f%10.3f\n",x,y,z);}
    inline void round(Int_t n);
    inline friend std::ostream& operator << (std::ostream& put,const FairGeoVector& v);
    inline friend std::istream& operator >> (std::istream& get,FairGeoVector& v);
    ClassDef(FairGeoVector,1) // vector with 3 components
};

// -------------------- inlines ---------------------------

inline void FairGeoVector::setVector(const Double_t* a)
{
  x=a[0];
  y=a[1];
  z=a[2];
}

inline void FairGeoVector::setVector(const Float_t* a)
{
  x=a[0];
  y=a[1];
  z=a[2];
}

inline Double_t FairGeoVector::operator() (const Int_t i) const
{
  switch (i) {
  case 0:
    return x;
  case 1:
    return y;
  case 2:
    return z;
  default:
    Error("operator()","bad index");
  }
  return 0;
}

inline FairGeoVector FairGeoVector::operator - () const
{
  FairGeoVector p(-x,-y,-z);
  return p;
}

inline FairGeoVector& FairGeoVector::operator = (const FairGeoVector& v)
{
  x=v.getX();
  y=v.getY();
  z=v.getZ();
  return *this;
}

inline Bool_t FairGeoVector::operator == (const FairGeoVector& v) const
{
  return ((v.getX()!=x || v.getY()!=y || v.getZ()!=z) ? kFALSE : kTRUE);
}

inline  Bool_t FairGeoVector::operator != (const FairGeoVector& v) const
{
  return (v.getX()!=x || v.getY()!=y || v.getZ()!=z)  ? kTRUE : kFALSE;
}
/// check with ilse
inline Bool_t FairGeoVector::operator < (const Double_t a)
{
  return (x>=a || y>=a || z>=a) ? kFALSE : kTRUE;
}

inline Bool_t FairGeoVector::operator <= (const Double_t a)
{
  return (x>a || y>a || z>a) ? kFALSE : kTRUE;
}

inline Bool_t FairGeoVector::operator > (const Double_t a)
{
  return (x<=a || y<=a || z<=a) ? kFALSE : kTRUE;
}

inline Bool_t FairGeoVector::operator >= (const Double_t a)
{
  return (x<a || y<a || z<a) ? kFALSE : kTRUE;
}

inline FairGeoVector& FairGeoVector::operator += (const Double_t a)
{
  x+=a;
  y+=a;
  z+=a;
  return *this;
}

inline FairGeoVector& FairGeoVector::operator -= (const Double_t a)
{
  x-=a;
  y-=a;
  z-=a;
  return *this;
}

inline FairGeoVector& FairGeoVector::operator *= (const Double_t a)
{
  x*=a;
  y*=a;
  z*=a;
  return *this;
}

inline FairGeoVector& FairGeoVector::operator /= (const Double_t a)
{
  x/=a;
  y/=a;
  z/=a;
  return *this;
}

inline FairGeoVector& FairGeoVector::operator += (const FairGeoVector& v)
{
  x+=v.getX();
  y+=v.getY();
  z+=v.getZ();
  return *this;
}

inline FairGeoVector& FairGeoVector::operator -= (const FairGeoVector& v)
{
  x-=v.getX();
  y-=v.getY();
  z-=v.getZ();
  return *this;
}

inline FairGeoVector FairGeoVector::operator + (const FairGeoVector& v) const
{
  FairGeoVector p(*this);
  return p+=v;
}

inline FairGeoVector FairGeoVector::operator - (const FairGeoVector& v) const
{
  FairGeoVector p(*this);
  return p-=v;
}

inline FairGeoVector& FairGeoVector::abs()
{
  x=TMath::Abs(x);
  y=TMath::Abs(y);
  z=TMath::Abs(z);
  return *this;
}

inline Double_t FairGeoVector::scalarProduct(const FairGeoVector& v) const
{
  return (x*v.getX()+y*v.getY()+z*v.getZ());
}

inline FairGeoVector FairGeoVector::vectorProduct(const FairGeoVector& v) const
{
  FairGeoVector p(y*v.getZ()-z*v.getY(),z*v.getX()-x*v.getZ(),
                  x*v.getY()-y*v.getX());
  return p;
}

inline void FairGeoVector::round(Double_t d,Int_t n)
{
  // rounds d to a precision with n digits
  if(d>0) { d=floor(d*pow(10.,n)+0.5)/pow(10.,n); }
  else { d=-floor((-d)*pow(10.,n)+0.5)/pow(10.,n); }
}

inline void FairGeoVector::round(Int_t n)
{
  // rounds every component to a precision with n digits
  round(x,n);
  round(y,n);
  round(z,n);
}

inline std::ostream& operator << (std::ostream& put,const FairGeoVector& v)
{
  return put<<v(0)<<"  "<<v(1)<<"  "<<v(2)<<'\n';
}

inline std::istream& operator >> (std::istream& get,FairGeoVector& v)
{
  Double_t x[3];
  get>>x[0]>>x[1]>>x[2];
  v.setVector(x);
  return get;
}

#endif /* !FAIRGEOVECTOR_H */













/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOVOLUME_H
#define FAIRGEOVOLUME_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoMedium.h"              // for FairGeoMedium
#include "FairGeoTransform.h"           // for FairGeoTransform
#include "FairGeoVector.h"              // for FairGeoVector

#include "Rtypes.h"                     // for Int_t, Text_t, Double_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

#include <stddef.h>                     // for NULL

/**
 * basic geometry parameters of a volume
 * @author Ilse koenig
 */
class FairGeoVolume : public TNamed
{
  private:
    FairGeoVolume& operator=(const  FairGeoVolume&);
  protected:
    TString shape;              /**eant shape of the volume*/
    TString mother;            /** Name of the mother volume*/
    TObjArray* points;        /** array of points (type FairGeoVector)*/
    FairGeoTransform transform; /** transformation relative to the mother system */
    FairGeoTransform fLabTransform; /** transformation to the LAB system; */
    FairGeoMedium   fMedium;    /** medium properties */
    Int_t nPoints;             /** number of points */
    Int_t fHadFormat; //
    Int_t fgMCid;     /** Volume Id given by MC*/

  public:
    inline FairGeoVolume();
    FairGeoVolume(FairGeoVolume&);
    virtual ~FairGeoVolume();
    const TString& getName() const { return fName; }
    const TString& getShape() const { return shape; }
    const TString& getMother() const { return mother; }
    FairGeoTransform& getTransform() { return transform; }
    FairGeoTransform& getLabTransform() { return fLabTransform;}
    FairGeoMedium&    getMedium() { return fMedium;}
    Int_t getNumPoints() { return nPoints;}
    inline FairGeoVector* getPoint(const Int_t n);
    inline void setName(const Text_t* s);
    void setVolumePar(FairGeoVolume&);
    inline void setShape(const Text_t* s);
    inline void setMother(const Text_t* s);
    void createPoints(const Int_t);
    void setPoint(const Int_t,const Double_t,const Double_t,const Double_t);
    void setPoint(const Int_t,const FairGeoVector&);
    virtual void clear();
    virtual void print();
    virtual void setHadFormat( Int_t i ) { fHadFormat=i;}
    Double_t getVolParameter( Int_t nPoint, Int_t pos );
    Int_t getMCid() {return fgMCid;}
    void setMCid(Int_t MCid) {fgMCid=MCid;}

    ClassDef(FairGeoVolume,1) //
};

// -------------------- inlines --------------------------

inline FairGeoVolume::FairGeoVolume()
  :TNamed(),
   shape(""),
   mother(""),
   points(NULL),
   transform(FairGeoTransform()),
   fLabTransform(FairGeoTransform()),
   fMedium(0),
   nPoints(0),
   fHadFormat(0),
   fgMCid(0)
{
}


inline FairGeoVector* FairGeoVolume::getPoint(const Int_t n)
{
  if (points && n<nPoints) { return static_cast<FairGeoVector*>(points->At(n)); }
  else { return 0; }
}

inline void FairGeoVolume::setName(const Text_t* s)
{
  fName=s;
  fName.ToUpper();
}

inline void FairGeoVolume::setShape(const Text_t* s)
{
  shape=s;
  shape.ToUpper();
}

inline void FairGeoVolume::setMother(const Text_t* s)
{
  mother=s;
  mother.ToUpper();
}

#endif /* !FAIRGEOVOLUME_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOCOMPOSITEVOLUME_H
#define FAIRGEOCOMPOSITEVOLUME_H

#include "FairGeoVolume.h"              // for FairGeoVolume

#include "Rtypes.h"                     // for Int_t, etc

class TObjArray;
/**
 * basic geometry of a volume with components
 * @author Ilse koenig
 */
class FairGeoCompositeVolume : public FairGeoVolume
{
  protected:
    TObjArray* components;    // array of components (type FairGeoVolume)
  public:
    FairGeoCompositeVolume(Int_t nComp=0);
    ~FairGeoCompositeVolume();
    Int_t getNumComponents();
    FairGeoVolume* getComponent(const Int_t);
    void createComponents(const Int_t);
    void setComponent(FairGeoVolume*,const Int_t);
    void clear();
    void print();
    ClassDef(FairGeoCompositeVolume,1)
  private:
    FairGeoCompositeVolume(const FairGeoCompositeVolume& );
    FairGeoCompositeVolume& operator=(const FairGeoCompositeVolume&);

};

#endif /* !FAIRGEOCOMPOSITEVOLUME_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOASCIIIO_H
#define FAIRGEOASCIIIO_H

#include "FairGeoIo.h"                  // for FairGeoIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Bool_t, etc
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

class FairGeoSet;
class FairGeoMedia;
class FairGeoInterface;

/**
 * Class for geometry I/O from ASCII file
 * @author Ilse Koenig
 */
class FairGeoAsciiIo: public FairGeoIo
{
    TString  filename;
    TString  filedir;
    Bool_t   writable;
    std::fstream* file;
  public:
    FairGeoAsciiIo();
    virtual ~FairGeoAsciiIo();
    void setDirectory(const char* fDir) {filedir=fDir;}
    const char* getDirectory() {return filedir.Data();}
    const char* getFilename() {return filename.Data();}
    Bool_t open(const char*,const Text_t* status="in");
    Bool_t isOpen();
    Bool_t isWritable();
    void close();
    void print();
    Bool_t read(FairGeoMedia*);
    Bool_t read(FairGeoSet*,FairGeoMedia*);
    Bool_t write(FairGeoMedia*);
    Bool_t write(FairGeoSet* set);
    Bool_t readGeomConfig(FairGeoInterface*);
    Bool_t readDetectorSetup(FairGeoInterface*);
    Bool_t setSimulRefRun(const char*) {return kTRUE;}
    Bool_t setHistoryDate(const char*) {return kTRUE;}
  private:
    FairGeoAsciiIo(const FairGeoAsciiIo&);
    FairGeoAsciiIo& operator=(const FairGeoAsciiIo&);
    ClassDef(FairGeoAsciiIo,0) // Class for geometry I/O from ASCII file
};

#endif  /* !FAIRGEOASCIIIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOBRIK_H
#define FAIRGEOBRIK_H

#include "FairGeoBasicShape.h"          // for FairGeoBasicShape

#include "Rtypes.h"                     // for FairGeoBrik::Class, etc


class FairGeoTransform;
class FairGeoVolume;
class TArrayD;

class FairGeoBrik : public FairGeoBasicShape
{
  public:
    FairGeoBrik();
    ~FairGeoBrik();
    TArrayD* calcVoluParam(FairGeoVolume*);
    void calcVoluPosition(FairGeoVolume*,
                          const FairGeoTransform&,const FairGeoTransform&);
    ClassDef(FairGeoBrik,0) // class for geometry shape BOX or BRIK
};

#endif  /* !FAIRGEOBRIK_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGEOBASICSHAPE_H
#define FAIRGEOBASICSHAPE_H

#include "TNamed.h"                     // for TNamed

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, etc

#include <fstream>                      // for fstream

class FairGeoTransform;
class FairGeoVolume;
class TArrayD;
/**
 * base class for all shapes
 * @author Ilse koenig
 */
class FairGeoBasicShape : public TNamed
{
  protected:
    Int_t nPoints;            // number of points describing the shape
    Int_t nParam;             // number of parameters needed to create the ROOT shape
    TArrayD* param;           // parameters needed to create the ROOT shape
    FairGeoTransform* center;   // position of the volume center in the technical KS
    FairGeoTransform* position; // position of the ROOT volume in its ROOT mother
  public:
    FairGeoBasicShape();
    virtual ~FairGeoBasicShape();
    Int_t getNumPoints() {return nPoints;}
    Int_t getNumParam() {return nParam;}
    TArrayD* getParam() {return param;}
    FairGeoTransform* getCenterPosition() {return center;}
    FairGeoTransform* getVoluPosition() {return position;}
    virtual Int_t readPoints(std::fstream*,FairGeoVolume*);
    virtual Bool_t writePoints(std::fstream*,FairGeoVolume*);
    virtual void printPoints(FairGeoVolume* volu);
    virtual TArrayD* calcVoluParam(FairGeoVolume*) {return 0;}
    virtual void calcVoluPosition(FairGeoVolume*,const FairGeoTransform&);
    virtual void calcVoluPosition(FairGeoVolume*,const FairGeoTransform&,
                                  const FairGeoTransform&) {return;}
    void printParam();
  protected:
    void posInMother(const FairGeoTransform&,const FairGeoTransform&);
    ClassDef(FairGeoBasicShape,0) // base class for all shapes
  private:
    FairGeoBasicShape(const FairGeoBasicShape&);
    FairGeoBasicShape& operator=(const FairGeoBasicShape&);

};

#endif  /* !FAIRGEOBASICSHAPE_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

warning: expression result unused [-Wunused-value]
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:22:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1.h:35:3: error: typedef redefinition with different types ('struct s_ve10_1' vs 'struct s_ve10_1')
} s_ve10_1;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ve10_1.h:35:3: note: previous definition is here
} s_ve10_1;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:23:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1.h:35:3: error: typedef redefinition with different types ('struct s_ves10_1' vs 'struct s_ves10_1')
} s_ves10_1 ;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_ves10_1.h:35:3: note: previous definition is here
} s_ves10_1 ;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:24:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe.h:31:3: error: typedef redefinition with different types ('struct s_evhe' vs 'struct s_evhe')
} s_evhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_evhe.h:31:3: note: previous definition is here
} s_evhe;
  ^
In file included from G__BaseDict dictionary payload:7353:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:25:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe_swap.h:11:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe.h:48:3: error: typedef redefinition with different types ('struct s_bufhe' vs 'struct s_bufhe')
} s_bufhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_bufhe.h:48:3: note: previous definition is here
} s_bufhe;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:43:3: error: typedef redefinition with different types ('struct s_taghe' vs 'struct s_taghe')
} s_taghe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:43:3: note: previous definition is here
} s_taghe;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:48:3: error: typedef redefinition with different types ('struct s_tag' vs 'struct s_tag')
} s_tag;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:48:3: note: previous definition is here
} s_tag;
  ^
In file included from G__BaseDict dictionary payload:7353:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:89:3: error: typedef redefinition with different types ('struct s_evt_channel' vs 'struct s_evt_channel')
} s_evt_channel;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/f_evt.h:89:3: note: previous definition is here
} s_evt_channel;
  ^
In file included from G__BaseDict dictionary payload:7354:
In file included from /data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe_swap.h:12:
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe.h:74:3: error: typedef redefinition with different types ('struct s_filhe' vs 'struct s_filhe')
} s_filhe;
  ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/s_filhe.h:74:3: note: previous definition is here
} s_filhe;
  ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRunSim with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      if (fSorter!= 0) { delete fSorter; }
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairLogger;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
    /**ctor*/
    FairRootManager();
    /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString BrName);
    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);
    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:
    /**private methods*/
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );
    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);


    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRootManager*  fgInstance;
#else
    static                FairRootManager*  fgInstance;
#endif

    /**Branch id for this run */
    Int_t                               fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,11) // Root IO manager
};


#endif //FAIR_ROOT_MANAGER_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
#if !defined(__CINT__)
    static TMCThreadLocal FairRun* fRunInstance;
#else
    static                FairRun* fRunInstance;
#endif
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    const char*              fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager, 
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();
                                               
  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //! 
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //! 

    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
#if !defined(__CINT__)
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
#else
    static                FairRunSim*  fginstance;//!              /** Singleton Instance */
#endif
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#endif

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the
        subtasks. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action after each event. To be implemented in the derived class **/
    virtual void Finish() { };

    //  /** Action after each event. To be implemented in the derived class **/
    //  virtual void FinishTask() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,3);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    void SetGenerateHtml(Bool_t flag, const char* histFileName, Int_t refreshRate);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    TFolder*    fFolder;       //!
    Bool_t      fGenerateHtml; //!
    TString     fHistFileName; //!
    Int_t       fRefreshRate;  //!
    Int_t       fNevents;      //!

    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    void WriteObjects();
    void GenerateHtml();

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
#if !defined(__CINT__)
    static TMCThreadLocal FairLinkManager* fgInstance;
#else
    static                FairLinkManager* fgInstance;
#endif

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairStack header file                    -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone  Flag for tracking
     *@param parentID  Index of mother particle
     *@param pdgCode   Particle type (PDG encoding)
     *@param px,py,pz  Momentum components at start vertex [GeV]
     *@param e         Total energy at start vertex [GeV]
     *@param vx,vy,vz  Coordinates of start vertex [cm]
     *@param time      Start time of track [s]
     *@param polx,poly,polz Polarisation vector
     *@param proc      Production mechanism (VMC encoding)
     *@param ntr       Track number (filled by the stack)
     *@param weight    Particle weight
     *@param is        Generation status code (whatever that means)
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is);

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/

    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID);


    /** Virtual method PopNextTrack.
     ** Gets next particle for tracking from the stack.
     *@param  iTrack  index of popped track
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopNextTrack(Int_t& iTrack);


    /** Virtual method PopPrimaryForTracking.
     ** Gets primary particle by index for tracking from stack.
     *@param  iPrim   index of primary particle
     *@return Pointer to the TParticle of the track
     **/
    virtual TParticle* PopPrimaryForTracking(Int_t iPrim);


    /** Add a TParticle to the fParticles array **/
    void AddParticle(TParticle* part);


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray();


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0);


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset();


    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register();


    /** Output to screen
     **@param iVerbose: 0=events summary, 1=track info
     **/
    virtual void Print(Option_t* option="") const;


    /** Modifiers  **/
    virtual void SetCurrentTrack(Int_t iTrack);

    /** Accessors **/
    virtual Int_t GetNtrack() const;   // Total number of tracks
    virtual Int_t GetNprimary() const; // Number of primaries
    virtual TParticle* GetCurrentTrack() const;
    virtual Int_t GetCurrentTrackNumber() const;
    virtual Int_t GetCurrentParentTrackNumber() const;
    virtual TParticle* GetParticle(Int_t) const { return NULL; }

    virtual TClonesArray* GetListOfParticles() { return NULL; } 

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*            fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)


};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
#if ROOT_VERSION_CODE < 333824
    /** Calculate user field  b at point x */
    virtual void          Field(const Double_t* x, Double_t* b) const;      // MC Application
#endif
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init worker run (used in MT mode only) */
    virtual void InitForWorker() const;

    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    void RegisterStack();

    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairRootManager*      fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!

    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include "Riosfwd.h"   // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0.);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register();
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for ostream, cout

class FairLink : public TObject
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    virtual ~FairLink();

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = file;
      fEntry = entry;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      fFile = -1;
      fEntry = -1;
      fType = type;
      fIndex = index;
      fWeight = weight;
    };
    Int_t GetFile() const {return fFile;}
    Int_t GetEntry() const {return fEntry;}
    Int_t GetType() const {return fType;}
    Int_t GetIndex() const {return fIndex;}
    Float_t GetWeight() const {return fWeight;}

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}

    virtual void PrintLinkInfo(std::ostream& out = std::cout) const;

    virtual bool operator==(const FairLink& link) const {
      if ((fFile == link.GetFile() || link.GetFile() == -1) && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    virtual bool operator<(const FairLink& link) const {
	if (fFile != -1 && link.GetFile() != -1){
		if (fFile < link.GetFile()) 		return true;
		else if (link.GetFile() < fFile) 	return false;
	}
	if (fEntry != -1 && link.GetEntry() != -1){
		if(fEntry < link.GetEntry())		return true;
		else if (link.GetEntry() < fEntry)	return false;
	}
	if (fType < link.GetType())				return true;
	else if (link.GetType() < fType)		return false;
	if (fIndex < link.GetIndex())			return true;
	else if (link.GetIndex() < fIndex)		return false;

	return false;
//      if (fFile != -1 && fFile < link.GetFile()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1) && fEntry < link.GetEntry()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType < link.GetType()) {
//        return true;
//      } else if ((fFile == link.GetFile() || link.GetFile() == -1)  && (fEntry == link.GetEntry() || link.GetEntry() == -1) && fType == link.GetType() && fIndex < link.GetIndex()) {
//        return true;
//      } else {
//        return false;
//      }
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDef(FairLink, 3);


  private:
    Int_t fFile;
    Int_t fEntry;
    Int_t fType;
    Int_t fIndex;
    Float_t fWeight;

};

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#ifndef __CINT__
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    #ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;

    #endif // for BOOST serialization
    
    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    virtual FairMultiLinkedData* 		GetPointerToLinks() const {	return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:

    Int_t fVerbose; //!
    Bool_t fInsertHistory; //!
    FairMultiLinkedData* fLink;

    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!
    FairLogger* fLogger;

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#ifndef __CINT__ // for BOOST serialization
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#endif //__CINT__

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp();
    /** Accessors **/
    virtual Double_t GetTimeStamp()             const { return fTimeStamp; };
    virtual Double_t GetTimeStampError()     const { return fTimeStampError;};
    virtual FairLink GetEntryNr() const {return fEntryNr;}
    /** Modifiers **/
    virtual void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    virtual void SetTimeStampError(Double_t t) {fTimeStampError = t;}
    virtual void SetEntryNr(FairLink entry) {fEntryNr = entry;}
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }


    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};


    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
#ifndef __CINT__ // for BOOST serialization
    friend class boost::serialization::access;
#endif // for BOOST serialization

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */
    FairLink fEntryNr; //!  indicates where the data is stored in the branch

    ClassDef(FairTimeStamp,3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "RVersion.h"                   // for ROOT_VERSION_CODE
#include "Riosfwd.h"                    // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc

#if ROOT_VERSION_CODE < 333824

#ifndef ROOT_TVirtualMagField
#define ROOT_TVirtualMagField
// copied from ROOT for backward compatibility with ROOT versions before 5.24
#include "TNamed.h"

class TVirtualMagField : public TNamed
{
  public:
    TVirtualMagField()                 : TNamed() {}
    TVirtualMagField(const char* name) : TNamed(name,"") {}
    virtual ~TVirtualMagField() {}
    virtual void Field(const Double_t* x, Double_t* B) = 0;
    ClassDef(TVirtualMagField, 1)              // Abstract base field class
};
ClassImp(TVirtualMagField)
#endif


#else

#include "TVirtualMagField.h"

#endif

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    void OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName) {return;}
    virtual void   ReadBranchEvent(const char* BrName, Int_t Event) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:80:28: error: allocation of incomplete type 'FairRunSim'
    FairRunSim* fRun = new FairRunSim();
                           ^~~~~~~~~~
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:81:9: error: member access into incomplete type 'FairRunSim'
    fRun->SetName("TGeant3");                     // Transport engine
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:82:9: error: member access into incomplete type 'FairRunSim'
    fRun->SetOutputFile(mcFile);                  // Output file
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:83:9: error: member access into incomplete type 'FairRunSim'
    fRun->SetGenerateRunInfo(kTRUE);              // Create FairRunInfo file
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:84:31: error: member access into incomplete type 'FairRunSim'
    FairRuntimeDb* rtdb = fRun->GetRuntimeDb();
                              ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:116:9: error: member access into incomplete type 'FairRunSim'
    fRun->SetMaterials("media.geo"); // Materials
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:149:5: error: unknown type name 'CbmTarget'
    CbmTarget* target = new CbmTarget(targetElement.Data(), targetThickness, targetDiameter);
    ^
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:149:29: error: unknown type name 'CbmTarget'
    CbmTarget* target = new CbmTarget(targetElement.Data(), targetThickness, targetDiameter);
                            ^
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:153:9: error: member access into incomplete type 'FairRunSim'
    fRun->AddModule(target);
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:160:5: error: unknown type name 'CbmFieldMap'
    CbmFieldMap* magField = CbmSetup::Instance()->CreateFieldMap();
    ^
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:160:29: error: use of undeclared identifier 'CbmSetup'
    CbmFieldMap* magField = CbmSetup::Instance()->CreateFieldMap();
                            ^
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:167:9: error: member access into incomplete type 'FairRunSim'
    fRun->SetField(magField);
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:172:41: error: allocation of incomplete type 'FairPrimaryGenerator'
    FairPrimaryGenerator* primGen = new FairPrimaryGenerator();
                                        ^~~~~~~~~~~~~~~~~~~~
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:32:7: note: forward declaration of 'FairPrimaryGenerator'
class FairPrimaryGenerator;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:181:12: error: member access into incomplete type 'FairPrimaryGenerator'
    primGen->SetTarget(tZ, tDz);
           ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:32:7: note: forward declaration of 'FairPrimaryGenerator'
class FairPrimaryGenerator;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:182:12: error: member access into incomplete type 'FairPrimaryGenerator'
    primGen->SetBeam(0., 0., beamWidthX, beamWidthY);
           ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:32:7: note: forward declaration of 'FairPrimaryGenerator'
class FairPrimaryGenerator;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:183:12: error: member access into incomplete type 'FairPrimaryGenerator'
    primGen->SmearGausVertexXY(smearVertexXY);
           ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:32:7: note: forward declaration of 'FairPrimaryGenerator'
class FairPrimaryGenerator;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:184:12: error: member access into incomplete type 'FairPrimaryGenerator'
    primGen->SmearVertexZ(smearVertexZ);
           ^
/data/ROOT6/install_v-16.06b-FairSoft_may16/include/FairGenerator.h:32:7: note: forward declaration of 'FairPrimaryGenerator'
class FairPrimaryGenerator;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:187:9: error: unknown type name 'CbmUnigenGenerator'
        CbmUnigenGenerator*  uniGen = new CbmUnigenGenerator(urqmdFile);
        ^
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:187:43: error: unknown type name 'CbmUnigenGenerator'
        CbmUnigenGenerator*  uniGen = new CbmUnigenGenerator(urqmdFile);
                                          ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairParRootFileIo with content:

#line 1 "G__ParBaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, ClassDef, etc
#include "TList.h"                      // for TList
#include "TString.h"                    // for TString

class FairLogger;
class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;
    /** Fair Logger */
    FairLogger*  fLogger;//!
  public:
    FairContainer( const char*, const char*, const char*);
    ~FairContainer();
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDef(FairContainer,0) // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    virtual ~FairContFact();
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) {return 0;}
    virtual void activateParIo(FairParIo*) {}
  protected:

    TList* containers;   // all parameter containers managed by this factory
    const char* getActualContext(const char* name) {
      return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    /** Fair Logger */
    FairLogger*  fLogger;//!
    ClassDef(FairContFact,0) // base class of all factories for parameter containers
  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);


};

#endif  /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"               // for FairDetParIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Text_t, Bool_t, etc
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;  //! header of container output in file
    TString sepLine;  //! comment line
    std::fstream* pFile;   //! pointer to ascii file
// virtual Bool_t write(HDetector*) {return kTRUE;}
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*,Int_t);
    void writeHeader(const Text_t*, const Text_t* context="",
                     const Text_t* author="", const Text_t* description="");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);
//  Bool_t readLabPositions(const Text_t*,HDetGeomPar*,Int_t*,Int_t,Int_t);
//  Bool_t readVolumes(const Text_t*,HDetGeomPar*);
//  void readTransform(HGeomTransform&);
//  Bool_t readVolume(HGeomVolume*,HGeomShapes*,Text_t*);
//  void writeTransform(const HGeomTransform&);
//  void writeVolume(HGeomVolume*,HGeomShapes*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}
//  Bool_t read(HDetGeomPar*,Int_t*);
//  Int_t writeFile(HDetGeomPar*);

  private:

    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDef(FairDetParAsciiFileIo,0) // Class for detector parameter I/O from ascii file
};

#endif  /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairDetParIo::Class, etc

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber; // input number (first or second input in runtime database)
  public:
    FairDetParIo();
    virtual ~FairDetParIo() {;}

    // sets the input number
    void setInputNumber(Int_t n) {inputNumber=n;}

    // returns the input number
    Int_t getInputNumber() {return inputNumber;}

    // initializes parameter container
    virtual Bool_t init(FairParSet*) {return kFALSE;}

    // writes parameter container to output
    virtual Int_t write(FairParSet*) {return kFALSE;}

    ClassDef(FairDetParIo,0)  // Base class for detector parameter IO
};

#endif  /* !HDETPARIO_H */







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"               // for FairDetParIo

#include "Rtypes.h"                     // for Int_t, Text_t, etc

using std::fstream;

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;    // pointer to parameter ROOT file
  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*);
//  Bool_t read(HDetGeomPar*,Int_t*);
  protected:
    Int_t findInputVersion(Text_t* contName);
    Int_t getMaxVersion(Text_t* contName);
    TObject* findContainer(Text_t* contName, Int_t version);
  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator= (const FairDetParRootFileIo&);

    ClassDef(FairDetParRootFileIo,0) // detector base class for parameter I/O from ROOT file
};

#endif  /* !FAIRDETPARROOTFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"      // for FairDetParAsciiFileIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, Bool_t, etc

#include <fstream>                      // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f=0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*);
    Int_t write(FairParSet*);
  private:

    ClassDef(FairGenericParAsciiFileIo,0) // I/O from Ascii file for parameter containers derived from FairParGenericSet
    Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template <class type> const UChar_t* readData(type,const Char_t*,TString&,Int_t&);
    template <class type> void writeData(type*,Int_t);
};

#endif  /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"       // for FairDetParRootFileIo

#include "Rtypes.h"                    // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f=0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*);
    ClassDef(FairGenericParRootFileIo,0) // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif  /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"                  // for FairParIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Bool_t, Text_t, etc

#include <fstream>                      // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;      // pointer to a file
  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status="in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status="in");

    // closes file
    void close();

    // returns kTRUE if file is open
    Bool_t check() {
      if (file) { return (file->rdbuf()->is_open()==1); }
      else { return kFALSE; }
    }

    // prints information about the file and the detector I/Os
    void print();

    std::fstream* getFile();
  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDef(FairParAsciiFileIo,0) // Parameter I/O from ASCII files
};

#endif  /* !FAIRPARASCIIFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"                 // for FairParSet

#include "Rtypes.h"                     // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name,const char* title,const char* context, Bool_t ownership=kFALSE)
      : FairParSet(name,title,context,ownership) {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*)=0;
    virtual Bool_t getParams(FairParamList*)=0;
    virtual void printParams();

    Bool_t init(FairParIo* inp);
    Int_t  write(FairParIo* output);

   // DB add on
    void fill(UInt_t) {};
    void store(UInt_t) {};

  protected:
    FairParGenericSet()
      : FairParSet() {}
    ClassDef(FairParGenericSet,1) // Base class for generic-style parameter containers
};

#endif  /* !FAIRPARGENERICSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Text_t, etc
#include "TString.h"                    // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;  // list of detector I/Os
    Bool_t autoWritable;  // flag indicating if automatic write is possible
    TString filename;
  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() {;}

    // returns the filename
    const char* getFilename() {return filename.Data();}

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) {;}

    // prints information about input/output
    virtual void print() {;}

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) {;}

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() {;}

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f=kTRUE) {autoWritable=f;}
    Bool_t isAutoWritable() {return autoWritable;}

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDef(FairParIo,0) // Base class for all parameter I/Os
};

#endif  /* !FAIRPARIO_H */




/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"                  // for FairParIo

#include "Rtypes.h"                     // for Bool_t, Text_t, Int_t, etc
#include "TFile.h"                      // for TFile
#include "TNamed.h"                     // for TNamed

#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;     //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option="READ",
                    const Text_t* ftitle="",Int_t compress=1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() {return run;}
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() {return RootFile->IsOpen();}
    void   cd() {RootFile->cd();}
    Bool_t IsWritable() {return RootFile->IsWritable();}

    TKey* GetKey(Text_t* t) { return RootFile->GetKey(t);}
    TList* GetListOfKeys() { return RootFile->GetListOfKeys();}
    void Close() {RootFile->Close();}

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDef(FairParRootFile,0) // ROOT file for Parameter I/O

};


class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;  // pointer to ROOT file
    Bool_t fMerging;
  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option="READ",
                const Text_t* ftitle="",Int_t compress=1);
    Bool_t open(const TList* fnamelist, Option_t* option="READ",
                const Text_t* ftitle="",Int_t compress=1);
    void close();
    void print();
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*);
    TList* getKeys();
    Bool_t check() {
      // returns kTRUE if file is open
      if (file) { return file->IsOpen(); }
      else { return kFALSE; }
    }
    void cd() {
      // sets the global ROOT file pointer gFile
      if (file) { file->cd(); }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging( Bool_t io ) { fMerging=io;}

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDef(FairParRootFileIo,0) // Parameter I/O from ROOT files
};

#endif  /* !FAIRPARROOTFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include "TNamed.h"
#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TString.h"                    // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;         //
    TString fTitle;        //
    TString detName;         //! name of the detector the container belongs to
    Int_t versions[3];       //! versions of container in the 2 possible inputs
    Bool_t status;           //! static flag
    Bool_t changed;          //! flag is kTRUE if parameters have changed
    Bool_t  owned;          //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;    // Context/purpose for parameters and conditions
    TString author;          // Author of parameters
    TString description ;    // Description of parameters
    /** Fair Logger */
    FairLogger*  fLogger;  //!

  public:
    FairParSet(const char* name="",const char* title="",const char* context="", Bool_t owner=kFALSE);
    virtual ~FairParSet() {}

    virtual const char* GetName() const {return static_cast<const char*>(fName.Data());}
    virtual const char* GetTitle() const {return static_cast<const char*>(fTitle.Data());}

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() {return detName.Data();}
    void resetInputVersions();

    void setInputVersion(Int_t v=-1,Int_t i=0) {
      if (i>=0 && i<3) { versions[i]=v; }
    }
    Int_t getInputVersion(Int_t i) {
      if (i>=0 && i<3) { return versions[i]; }
      else { return 0; }
    }

    void setStatic(Bool_t flag=kTRUE) {status=flag;}
    Bool_t isStatic() {return status;}

    void setOwnership(Bool_t flag=kTRUE) {owned=flag;}
    Bool_t isOwned() {return owned;}

    void setChanged(Bool_t flag=kTRUE) {changed=flag;}
    Bool_t hasChanged() {return changed;}

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) {author=s;}
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) {description=s;}
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r) {
      author=r.getAuthor();
      description=r.getDescription();
    }


    virtual void fill(UInt_t) {};
    virtual void store(UInt_t) {};
    

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDef(FairParSet,2) // Base class for all parameter containers
};

#endif  /* !FAIRPARSET_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Text_t, Int_t, Bool_t, etc
#include "TArrayC.h"                    // for TArrayC
#include "TFile.h"                      // for TFile
#include "TList.h"                      // for TList
#include "TObject.h"                    // for TObject
#include "TROOT.h"                      // for TROOT, gROOT
#include "TSeqCollection.h"             // for TSeqCollection
#include "TString.h"                    // for TString

class FairLogger;
class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;    // Pointer to binary array
    Int_t arraySize;        // Size of binary array
    TString paramType;      // Type of parameter value or class name
    Bool_t basicType;       // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;    // number of bytes per value
    Int_t classVersion;     // Code version of classes stored as binary
    UChar_t* streamerInfo;  // Pointer to binary array container the streamer info
    Int_t streamerInfoSize; // Size of streamer info array
  public:
    FairParamObj(const Text_t* name="");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*,Int_t);
    FairParamObj(const Text_t*,Bool_t);
    FairParamObj(const Text_t*,UInt_t);
    FairParamObj(const Text_t*,Float_t);
    FairParamObj(const Text_t*,Double_t);
    FairParamObj(const Text_t*,const Int_t*,const Int_t);
    FairParamObj(const Text_t*,const UInt_t*,const Int_t);
    FairParamObj(const Text_t*,const Float_t*,const Int_t);
    FairParamObj(const Text_t*,const Double_t*,const Int_t);
    FairParamObj(const Text_t*,const Text_t*);
    FairParamObj(const Text_t*,const Char_t*,const Int_t);
    FairParamObj(const Text_t*,const UChar_t*,const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*,const Int_t);
    void setClassVersion(const Int_t v) { classVersion=v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*,const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();
  protected:
    template <class type> void printData(type*,Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    ClassDef(FairParamObj,0) // Class for binary parameter object (name + binary array)
};


class FairParamList : public TObject
{
  protected:
    TList* paramList;      // List for parameters stored as string
    FairLogger* fLogger;  // FairRoot logging mechanism
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile() {
          // Create StreamerInfo index
          Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;
          if (lenIndex < 5000) { lenIndex = 5000; }
          fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile() {
          delete fClassIndex;
          fClassIndex=0;
        }
    };
  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*,const Text_t*);
    void add(const Text_t*,Int_t);
    void add(const Text_t*,Bool_t);
    void add(const Text_t*,UInt_t);
    void add(const Text_t*,Float_t);
    void add(const Text_t*,Double_t);
    void add(const Text_t*,TArrayI&);
    void add(const Text_t*,TArrayC&);
    void add(const Text_t*,TArrayF&);
    void add(const Text_t*,TArrayD&);
    void add(const Text_t*,const UChar_t*,const Int_t);
    void add(const Text_t*,const Int_t*,const Int_t);
    void add(const Text_t*,const Float_t*,const Int_t);
    void add(const Text_t*,const Double_t*,const Int_t);
    void addObject(const Text_t*,TObject*);
    Bool_t fill(const Text_t*,Text_t*,const Int_t);
    Bool_t fill(const Text_t*,Int_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Bool_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,UInt_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Float_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Double_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,UChar_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,TArrayI*);
    Bool_t fill(const Text_t*,TArrayC*);
    Bool_t fill(const Text_t*,TArrayF*);
    Bool_t fill(const Text_t*,TArrayD*);
    Bool_t fillObject(const Text_t*,TObject*);
    void print();
    FairParamObj* find(const Text_t* name) {
      return static_cast<FairParamObj*>(paramList->FindObject(name));
    }
    TList* getList() { return paramList; }
  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    ClassDef(FairParamList,3) // Class for lists of parameters (of type FairParamObj)
};

#endif  /* !FAIRPARAMLIST_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include "TNamed.h"                     // for TNamed

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, Text_t, UInt_t, etc
#include "TString.h"                    // for TString

#include <stdio.h>                      // for sprintf, sscanf
#include <fstream>                      // for fstream

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3]; //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;      // version of the parameter container in the ROOT output file
  public:
    FairParVersion() : TNamed(),rootVersion(0) {}
    FairParVersion(Text_t* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v=-1,Int_t i=0) {
      if (i>=0 && i<3) { inputVersions[i]=v; }
    }
    Int_t getInputVersion(Int_t i) {
      if (i>=0 && i<3) { return inputVersions[i]; }
      else { return -1; }
    }
    void resetInputVersions() {
      for(Int_t i=0; i<3; i++) {inputVersions[i]=-1;}
    }
    void setRootVersion(Int_t v) {rootVersion=v;}
    Int_t getRootVersion() {return rootVersion;}
    ClassDef(FairParVersion,1) // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization
  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name,const Text_t* refName="");
    FairRtdbRun(Int_t r,Int_t rr=-1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() {return parVersions;}
    const Text_t* getRefRun() {return refRun.Data();}
    void setRefRun(Text_t* s) {refRun=s;}
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDef(FairRtdbRun,1) // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
  UInt_t r;
  sscanf(GetName(),"%i",&r);
  return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
  if (r==-1) { refRun=""; }
  else {
    char name[255];
    sprintf(name,"%i",r);
    refRun=name;
  }
}

#endif  /* !FAIRRTDBRUN_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, Text_t, etc
#include "TList.h"                      // for TList
#include "TString.h"                    // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;    //! list of container factories

class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb; //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;    // list of parameter containers
    TList* runs;             // list of runs
    FairParIo* firstInput;    // first (prefered) input for parameters
    FairParIo* secondInput;   // second input (used if not found in first input)
    FairParIo* output;        // output for parameters
    FairRtdbRun* currentRun;  // Current run
    TString currentFileName; // Name of current event file
    Bool_t versionsChanged;  // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput; // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger*  fLogger;  //!

    /**
     * Select which IO type to use.
     */
    typedef enum {
      UNKNOWN_Type    = 0,
      AsciiFileOutput = 1, // Ascii in-out-put
      RootFileOutput  = 2, // Root Files
      RootTSQLOutput  = 3  // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;//IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb(void);

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(Text_t*);
    void removeAllContainers(void);
    Bool_t initContainers(Int_t runId,Int_t refId=-1,const Text_t* fileName="");
    void setContainersStatic(Bool_t f=kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*,FairRtdbRun*,FairRtdbRun* refRun=0);

    FairRtdbRun* addRun(Int_t runId,Int_t refId=-1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(Text_t*);
    FairRtdbRun* getCurrentRun(void) {return currentRun;}
    Text_t const* getCurrentFileName() {return currentFileName.Data();}
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run,Text_t* container,
                           Int_t version,Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run,Text_t* container,Int_t version);
    void setVersionsChanged(Bool_t f=kTRUE) {versionsChanged=f;}
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() {return containerList;}
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator= (const  FairRuntimeDb&) {return *this;}
    Bool_t initContainers(void);

    ClassDef(FairRuntimeDb,0) // Class for runtime database
};

#endif  /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:243:37: error: allocation of incomplete type 'FairParRootFileIo'
    FairParRootFileIo* parOut = new FairParRootFileIo(kParameterMerged);
                                    ^~~~~~~~~~~~~~~~~
G__ParBaseDict dictionary forward declarations' payload:16:85: note: forward declaration of 'FairParRootFileIo'
class __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) FairParRootFileIo;
                                                                                    ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:244:11: error: member access into incomplete type 'FairParRootFileIo'
    parOut->open(parFile.Data());
          ^
G__ParBaseDict dictionary forward declarations' payload:16:85: note: forward declaration of 'FairParRootFileIo'
class __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) FairParRootFileIo;
                                                                                    ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRuntimeDb with content:

#line 1 "G__ParBaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, ClassDef, etc
#include "TList.h"                      // for TList
#include "TString.h"                    // for TString

class FairLogger;
class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;
    /** Fair Logger */
    FairLogger*  fLogger;//!
  public:
    FairContainer( const char*, const char*, const char*);
    ~FairContainer();
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDef(FairContainer,0) // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    virtual ~FairContFact();
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) {return 0;}
    virtual void activateParIo(FairParIo*) {}
  protected:

    TList* containers;   // all parameter containers managed by this factory
    const char* getActualContext(const char* name) {
      return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    /** Fair Logger */
    FairLogger*  fLogger;//!
    ClassDef(FairContFact,0) // base class of all factories for parameter containers
  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);


};

#endif  /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"               // for FairDetParIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Text_t, Bool_t, etc
#include "TString.h"                    // for TString

#include <fstream>                      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;  //! header of container output in file
    TString sepLine;  //! comment line
    std::fstream* pFile;   //! pointer to ascii file
// virtual Bool_t write(HDetector*) {return kTRUE;}
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*,Int_t);
    void writeHeader(const Text_t*, const Text_t* context="",
                     const Text_t* author="", const Text_t* description="");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);
//  Bool_t readLabPositions(const Text_t*,HDetGeomPar*,Int_t*,Int_t,Int_t);
//  Bool_t readVolumes(const Text_t*,HDetGeomPar*);
//  void readTransform(HGeomTransform&);
//  Bool_t readVolume(HGeomVolume*,HGeomShapes*,Text_t*);
//  void writeTransform(const HGeomTransform&);
//  void writeVolume(HGeomVolume*,HGeomShapes*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}
//  Bool_t read(HDetGeomPar*,Int_t*);
//  Int_t writeFile(HDetGeomPar*);

  private:

    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDef(FairDetParAsciiFileIo,0) // Class for detector parameter I/O from ascii file
};

#endif  /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairDetParIo::Class, etc

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber; // input number (first or second input in runtime database)
  public:
    FairDetParIo();
    virtual ~FairDetParIo() {;}

    // sets the input number
    void setInputNumber(Int_t n) {inputNumber=n;}

    // returns the input number
    Int_t getInputNumber() {return inputNumber;}

    // initializes parameter container
    virtual Bool_t init(FairParSet*) {return kFALSE;}

    // writes parameter container to output
    virtual Int_t write(FairParSet*) {return kFALSE;}

    ClassDef(FairDetParIo,0)  // Base class for detector parameter IO
};

#endif  /* !HDETPARIO_H */







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"               // for FairDetParIo

#include "Rtypes.h"                     // for Int_t, Text_t, etc

using std::fstream;

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;    // pointer to parameter ROOT file
  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*);
//  Bool_t read(HDetGeomPar*,Int_t*);
  protected:
    Int_t findInputVersion(Text_t* contName);
    Int_t getMaxVersion(Text_t* contName);
    TObject* findContainer(Text_t* contName, Int_t version);
  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator= (const FairDetParRootFileIo&);

    ClassDef(FairDetParRootFileIo,0) // detector base class for parameter I/O from ROOT file
};

#endif  /* !FAIRDETPARROOTFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"      // for FairDetParAsciiFileIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, Bool_t, etc

#include <fstream>                      // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f=0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*);
    Int_t write(FairParSet*);
  private:

    ClassDef(FairGenericParAsciiFileIo,0) // I/O from Ascii file for parameter containers derived from FairParGenericSet
    Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template <class type> const UChar_t* readData(type,const Char_t*,TString&,Int_t&);
    template <class type> void writeData(type*,Int_t);
};

#endif  /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"       // for FairDetParRootFileIo

#include "Rtypes.h"                    // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f=0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*);
    ClassDef(FairGenericParRootFileIo,0) // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif  /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"                  // for FairParIo

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Bool_t, Text_t, etc

#include <fstream>                      // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;      // pointer to a file
  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status="in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status="in");

    // closes file
    void close();

    // returns kTRUE if file is open
    Bool_t check() {
      if (file) { return (file->rdbuf()->is_open()==1); }
      else { return kFALSE; }
    }

    // prints information about the file and the detector I/Os
    void print();

    std::fstream* getFile();
  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDef(FairParAsciiFileIo,0) // Parameter I/O from ASCII files
};

#endif  /* !FAIRPARASCIIFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"                 // for FairParSet

#include "Rtypes.h"                     // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name,const char* title,const char* context, Bool_t ownership=kFALSE)
      : FairParSet(name,title,context,ownership) {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*)=0;
    virtual Bool_t getParams(FairParamList*)=0;
    virtual void printParams();

    Bool_t init(FairParIo* inp);
    Int_t  write(FairParIo* output);

   // DB add on
    void fill(UInt_t) {};
    void store(UInt_t) {};

  protected:
    FairParGenericSet()
      : FairParSet() {}
    ClassDef(FairParGenericSet,1) // Base class for generic-style parameter containers
};

#endif  /* !FAIRPARGENERICSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Text_t, etc
#include "TString.h"                    // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;  // list of detector I/Os
    Bool_t autoWritable;  // flag indicating if automatic write is possible
    TString filename;
  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() {;}

    // returns the filename
    const char* getFilename() {return filename.Data();}

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) {;}

    // prints information about input/output
    virtual void print() {;}

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) {;}

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() {;}

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f=kTRUE) {autoWritable=f;}
    Bool_t isAutoWritable() {return autoWritable;}

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDef(FairParIo,0) // Base class for all parameter I/Os
};

#endif  /* !FAIRPARIO_H */




/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"                  // for FairParIo

#include "Rtypes.h"                     // for Bool_t, Text_t, Int_t, etc
#include "TFile.h"                      // for TFile
#include "TNamed.h"                     // for TNamed

#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;     //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option="READ",
                    const Text_t* ftitle="",Int_t compress=1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() {return run;}
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() {return RootFile->IsOpen();}
    void   cd() {RootFile->cd();}
    Bool_t IsWritable() {return RootFile->IsWritable();}

    TKey* GetKey(Text_t* t) { return RootFile->GetKey(t);}
    TList* GetListOfKeys() { return RootFile->GetListOfKeys();}
    void Close() {RootFile->Close();}

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDef(FairParRootFile,0) // ROOT file for Parameter I/O

};


class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;  // pointer to ROOT file
    Bool_t fMerging;
  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option="READ",
                const Text_t* ftitle="",Int_t compress=1);
    Bool_t open(const TList* fnamelist, Option_t* option="READ",
                const Text_t* ftitle="",Int_t compress=1);
    void close();
    void print();
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*);
    TList* getKeys();
    Bool_t check() {
      // returns kTRUE if file is open
      if (file) { return file->IsOpen(); }
      else { return kFALSE; }
    }
    void cd() {
      // sets the global ROOT file pointer gFile
      if (file) { file->cd(); }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging( Bool_t io ) { fMerging=io;}

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDef(FairParRootFileIo,0) // Parameter I/O from ROOT files
};

#endif  /* !FAIRPARROOTFILEIO_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include "TNamed.h"
#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TString.h"                    // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;         //
    TString fTitle;        //
    TString detName;         //! name of the detector the container belongs to
    Int_t versions[3];       //! versions of container in the 2 possible inputs
    Bool_t status;           //! static flag
    Bool_t changed;          //! flag is kTRUE if parameters have changed
    Bool_t  owned;          //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;    // Context/purpose for parameters and conditions
    TString author;          // Author of parameters
    TString description ;    // Description of parameters
    /** Fair Logger */
    FairLogger*  fLogger;  //!

  public:
    FairParSet(const char* name="",const char* title="",const char* context="", Bool_t owner=kFALSE);
    virtual ~FairParSet() {}

    virtual const char* GetName() const {return static_cast<const char*>(fName.Data());}
    virtual const char* GetTitle() const {return static_cast<const char*>(fTitle.Data());}

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() {return detName.Data();}
    void resetInputVersions();

    void setInputVersion(Int_t v=-1,Int_t i=0) {
      if (i>=0 && i<3) { versions[i]=v; }
    }
    Int_t getInputVersion(Int_t i) {
      if (i>=0 && i<3) { return versions[i]; }
      else { return 0; }
    }

    void setStatic(Bool_t flag=kTRUE) {status=flag;}
    Bool_t isStatic() {return status;}

    void setOwnership(Bool_t flag=kTRUE) {owned=flag;}
    Bool_t isOwned() {return owned;}

    void setChanged(Bool_t flag=kTRUE) {changed=flag;}
    Bool_t hasChanged() {return changed;}

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) {author=s;}
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) {description=s;}
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r) {
      author=r.getAuthor();
      description=r.getDescription();
    }


    virtual void fill(UInt_t) {};
    virtual void store(UInt_t) {};
    

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDef(FairParSet,2) // Base class for all parameter containers
};

#endif  /* !FAIRPARSET_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Text_t, Int_t, Bool_t, etc
#include "TArrayC.h"                    // for TArrayC
#include "TFile.h"                      // for TFile
#include "TList.h"                      // for TList
#include "TObject.h"                    // for TObject
#include "TROOT.h"                      // for TROOT, gROOT
#include "TSeqCollection.h"             // for TSeqCollection
#include "TString.h"                    // for TString

class FairLogger;
class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;    // Pointer to binary array
    Int_t arraySize;        // Size of binary array
    TString paramType;      // Type of parameter value or class name
    Bool_t basicType;       // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;    // number of bytes per value
    Int_t classVersion;     // Code version of classes stored as binary
    UChar_t* streamerInfo;  // Pointer to binary array container the streamer info
    Int_t streamerInfoSize; // Size of streamer info array
  public:
    FairParamObj(const Text_t* name="");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*,Int_t);
    FairParamObj(const Text_t*,Bool_t);
    FairParamObj(const Text_t*,UInt_t);
    FairParamObj(const Text_t*,Float_t);
    FairParamObj(const Text_t*,Double_t);
    FairParamObj(const Text_t*,const Int_t*,const Int_t);
    FairParamObj(const Text_t*,const UInt_t*,const Int_t);
    FairParamObj(const Text_t*,const Float_t*,const Int_t);
    FairParamObj(const Text_t*,const Double_t*,const Int_t);
    FairParamObj(const Text_t*,const Text_t*);
    FairParamObj(const Text_t*,const Char_t*,const Int_t);
    FairParamObj(const Text_t*,const UChar_t*,const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*,const Int_t);
    void setClassVersion(const Int_t v) { classVersion=v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*,const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();
  protected:
    template <class type> void printData(type*,Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    ClassDef(FairParamObj,0) // Class for binary parameter object (name + binary array)
};


class FairParamList : public TObject
{
  protected:
    TList* paramList;      // List for parameters stored as string
    FairLogger* fLogger;  // FairRoot logging mechanism
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile() {
          // Create StreamerInfo index
          Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;
          if (lenIndex < 5000) { lenIndex = 5000; }
          fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile() {
          delete fClassIndex;
          fClassIndex=0;
        }
    };
  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*,const Text_t*);
    void add(const Text_t*,Int_t);
    void add(const Text_t*,Bool_t);
    void add(const Text_t*,UInt_t);
    void add(const Text_t*,Float_t);
    void add(const Text_t*,Double_t);
    void add(const Text_t*,TArrayI&);
    void add(const Text_t*,TArrayC&);
    void add(const Text_t*,TArrayF&);
    void add(const Text_t*,TArrayD&);
    void add(const Text_t*,const UChar_t*,const Int_t);
    void add(const Text_t*,const Int_t*,const Int_t);
    void add(const Text_t*,const Float_t*,const Int_t);
    void add(const Text_t*,const Double_t*,const Int_t);
    void addObject(const Text_t*,TObject*);
    Bool_t fill(const Text_t*,Text_t*,const Int_t);
    Bool_t fill(const Text_t*,Int_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Bool_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,UInt_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Float_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,Double_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,UChar_t*,const Int_t nValues=1);
    Bool_t fill(const Text_t*,TArrayI*);
    Bool_t fill(const Text_t*,TArrayC*);
    Bool_t fill(const Text_t*,TArrayF*);
    Bool_t fill(const Text_t*,TArrayD*);
    Bool_t fillObject(const Text_t*,TObject*);
    void print();
    FairParamObj* find(const Text_t* name) {
      return static_cast<FairParamObj*>(paramList->FindObject(name));
    }
    TList* getList() { return paramList; }
  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    ClassDef(FairParamList,3) // Class for lists of parameters (of type FairParamObj)
};

#endif  /* !FAIRPARAMLIST_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include "TNamed.h"                     // for TNamed

#include "Riosfwd.h"                    // for fstream
#include "Rtypes.h"                     // for Int_t, Text_t, UInt_t, etc
#include "TString.h"                    // for TString

#include <stdio.h>                      // for sprintf, sscanf
#include <fstream>                      // for fstream

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3]; //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;      // version of the parameter container in the ROOT output file
  public:
    FairParVersion() : TNamed(),rootVersion(0) {}
    FairParVersion(Text_t* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v=-1,Int_t i=0) {
      if (i>=0 && i<3) { inputVersions[i]=v; }
    }
    Int_t getInputVersion(Int_t i) {
      if (i>=0 && i<3) { return inputVersions[i]; }
      else { return -1; }
    }
    void resetInputVersions() {
      for(Int_t i=0; i<3; i++) {inputVersions[i]=-1;}
    }
    void setRootVersion(Int_t v) {rootVersion=v;}
    Int_t getRootVersion() {return rootVersion;}
    ClassDef(FairParVersion,1) // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization
  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name,const Text_t* refName="");
    FairRtdbRun(Int_t r,Int_t rr=-1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() {return parVersions;}
    const Text_t* getRefRun() {return refRun.Data();}
    void setRefRun(Text_t* s) {refRun=s;}
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDef(FairRtdbRun,1) // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
  UInt_t r;
  sscanf(GetName(),"%i",&r);
  return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
  if (r==-1) { refRun=""; }
  else {
    char name[255];
    sprintf(name,"%i",r);
    refRun=name;
  }
}

#endif  /* !FAIRRTDBRUN_H */

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, Text_t, etc
#include "TList.h"                      // for TList
#include "TString.h"                    // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;    //! list of container factories

class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb; //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;    // list of parameter containers
    TList* runs;             // list of runs
    FairParIo* firstInput;    // first (prefered) input for parameters
    FairParIo* secondInput;   // second input (used if not found in first input)
    FairParIo* output;        // output for parameters
    FairRtdbRun* currentRun;  // Current run
    TString currentFileName; // Name of current event file
    Bool_t versionsChanged;  // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput; // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger*  fLogger;  //!

    /**
     * Select which IO type to use.
     */
    typedef enum {
      UNKNOWN_Type    = 0,
      AsciiFileOutput = 1, // Ascii in-out-put
      RootFileOutput  = 2, // Root Files
      RootTSQLOutput  = 3  // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;//IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb(void);

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(Text_t*);
    void removeAllContainers(void);
    Bool_t initContainers(Int_t runId,Int_t refId=-1,const Text_t* fileName="");
    void setContainersStatic(Bool_t f=kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*,FairRtdbRun*,FairRtdbRun* refRun=0);

    FairRtdbRun* addRun(Int_t runId,Int_t refId=-1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(Text_t*);
    FairRtdbRun* getCurrentRun(void) {return currentRun;}
    Text_t const* getCurrentFileName() {return currentFileName.Data();}
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run,Text_t* container,
                           Int_t version,Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run,Text_t* container,Int_t version);
    void setVersionsChanged(Bool_t f=kTRUE) {versionsChanged=f;}
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() {return containerList;}
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator= (const  FairRuntimeDb&) {return *this;}
    Bool_t initContainers(void);

    ClassDef(FairRuntimeDb,0) // Class for runtime database
};

#endif  /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:245:9: error: member access into incomplete type 'FairRuntimeDb'
    rtdb->setOutput(parOut);
        ^
G__ParBaseDict dictionary forward declarations' payload:22:82: note: forward declaration of 'FairRuntimeDb'
class __attribute__((annotate(R"ATTRDUMP(Class for runtime database)ATTRDUMP"))) FairRuntimeDb;
                                                                                 ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:246:9: error: member access into incomplete type 'FairRuntimeDb'
    rtdb->saveOutput();
        ^
G__ParBaseDict dictionary forward declarations' payload:22:82: note: forward declaration of 'FairRuntimeDb'
class __attribute__((annotate(R"ATTRDUMP(Class for runtime database)ATTRDUMP"))) FairRuntimeDb;
                                                                                 ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:247:9: error: member access into incomplete type 'FairRuntimeDb'
    rtdb->print();
        ^
G__ParBaseDict dictionary forward declarations' payload:22:82: note: forward declaration of 'FairRuntimeDb'
class __attribute__((annotate(R"ATTRDUMP(Class for runtime database)ATTRDUMP"))) FairRuntimeDb;
                                                                                 ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:252:9: error: member access into incomplete type 'FairRunSim'
    fRun->Run(nEvents);
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
In file included from input_line_9:1:
/data/ROOT6/trunk/macro/rich/alignment/misalignment_correction/gauss_distrib/run_sim.C:257:9: error: member access into incomplete type 'FairRunSim'
    fRun->CreateGeometryFile(geoFile);
        ^
G__BaseDict dictionary forward declarations' payload:32:7: note: forward declaration of 'FairRunSim'
class FairRunSim;
      ^
