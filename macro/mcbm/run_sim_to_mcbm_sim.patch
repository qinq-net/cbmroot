*** ../run/run_sim.C	2015-07-29 16:19:10.337101179 +0200
--- mcbm_sim.C	2015-07-31 13:46:38.226878764 +0200
***************
*** 14,20 ****
  //
  // --------------------------------------------------------------------------
  
! void run_sim(Int_t nEvents = 2, const char* setup = "sis100_electron")
  {
  
    // ========================================================================
--- 14,20 ----
  //
  // --------------------------------------------------------------------------
  
! void mcbm_sim(Int_t nEvents = 1, const char* setup = "sis18_mcbm")
  {
  
    // ========================================================================
***************
*** 55,66 ****
    // created by the placement of the target.
    //
    TString  targetElement   = "Gold";
!   Double_t targetThickness = 0.025;  // full thickness in cm
    Double_t targetDiameter  = 2.5;    // diameter in cm
    Double_t targetPosX      = 0.;     // target x position in global c.s. [cm]
    Double_t targetPosY      = 0.;     // target y position in global c.s. [cm]
    Double_t targetPosZ      = 0.;     // target z position in global c.s. [cm]
!   Double_t targetRotY      = 0.;     // target rotation angle around the y axis [deg]
    // ------------------------------------------------------------------------
  
  
--- 55,66 ----
    // created by the placement of the target.
    //
    TString  targetElement   = "Gold";
!   Double_t targetThickness = 0.25;   // full thickness in cm
    Double_t targetDiameter  = 2.5;    // diameter in cm
    Double_t targetPosX      = 0.;     // target x position in global c.s. [cm]
    Double_t targetPosY      = 0.;     // target y position in global c.s. [cm]
    Double_t targetPosZ      = 0.;     // target z position in global c.s. [cm]
!   Double_t targetRotY      = 30.;    // target rotation angle around the y axis [deg]
    // ------------------------------------------------------------------------
  
  
***************
*** 168,174 ****
    }
    
    if ( muchGeom != "" ) {
!     FairDetector* much = new CbmMuch("MUCH", kTRUE);
      much->SetGeometryFileName(muchGeom);
      fRun->AddModule(much);
    }
--- 168,174 ----
    }
    
    if ( muchGeom != "" ) {
!     FairDetector* much = new CbmMuchMcbm("MUCH", kTRUE);
      much->SetGeometryFileName(muchGeom);
      fRun->AddModule(much);
    }
***************
*** 208,220 ****
    // ------------------------------------------------------------------------
  
    // -----   Create magnetic field   ----------------------------------------
!   if ( 2 == fieldSymType ) {
!     CbmFieldMap* magField = new CbmFieldMapSym2(fieldMap);
!   }  else if ( 3 == fieldSymType ) {
!     CbmFieldMap* magField = new CbmFieldMapSym3(fieldMap);
!   } 
!   magField->SetPosition(0., 0., fieldZ);
!   magField->SetScale(fieldScale);
    fRun->SetField(magField);
    // ------------------------------------------------------------------------
  
--- 208,221 ----
    // ------------------------------------------------------------------------
  
    // -----   Create magnetic field   ----------------------------------------
! //  if ( 2 == fieldSymType ) {
! //    CbmFieldMap* magField = new CbmFieldMapSym2(fieldMap);
! //  }  else if ( 3 == fieldSymType ) {
! //    CbmFieldMap* magField = new CbmFieldMapSym3(fieldMap);
! //  } 
! //  magField->SetPosition(0., 0., fieldZ);
! //  magField->SetScale(fieldScale);
!   FairConstField* magField = new FairConstField();
    fRun->SetField(magField);
    // ------------------------------------------------------------------------
  
***************
*** 235,240 ****
--- 236,242 ----
    	tDz = target->GetThickness();
    }
    primGen->SetTarget(tZ, tDz);
+   //  primGen->SetTargetRotAngle(0., targetRotY * TMath::Pi()/180.);
    primGen->SetBeam(0., 0., beamWidthX, beamWidthY);
    primGen->SmearGausVertexXY(smearVertexXY);
    primGen->SmearVertexZ(smearVertexZ);
***************
*** 250,258 ****
--- 252,284 ----
    CbmUnigenGenerator*  uniGen = new CbmUnigenGenerator(inFile);
    uniGen->SetEventPlane(0. , 360.);
    primGen->AddGenerator(uniGen);
+ 
+   primGen->SetBeamAngle(targetRotY * TMath::Pi()/180.,0,0,0);  // set direction of beam to 30 degrees
+ 
    fRun->SetGenerator(primGen);       
    // ------------------------------------------------------------------------
  
+ //  // -----   Create Electron gun as alternative -----------------------------
+ //  FairPrimaryGenerator* primGen = new FairPrimaryGenerator();
+ //  // Use the FairBoxGenerator which generates a soingle electron
+ //  FairBoxGenerator *eminus = new FairBoxGenerator();
+ //  eminus->SetPDGType(11);
+ //  eminus->SetMultiplicity(1000);
+ //  //  eminus->SetBoxXYZ(32.,-32.,32.,-32.,0.);  // shoot at corner of diagonal modules
+ //  //  eminus->SetBoxXYZ(0., 0., 0., 0., 0.);  // shoot at corner of diagonal modules
+ //  //  eminus->SetBoxXYZ(57.,-57., 0., 0.,0.);  // shoot at corner of diagonal modules
+ //  //  eminus->SetBoxXYZ(-57.,-57., 57., 57.,0.);  // shoot at corner of diagonal modules
+ //  eminus->SetBoxXYZ(-180.,-15.,-150.,15.,0.);  // shoot at corner of diagonal modules
+ //  eminus->SetPRange(2.,2.);
+ //  eminus->SetPhiRange(0.,360.);
+ //  eminus->SetThetaRange(0.,0.);
+ //  primGen->AddGenerator(eminus);
+ //
+ //  //  primGen->SetBeamAngle(30*TMath::Pi()/180.,0,0,0);  // set direction of beam to 30 degrees
+ //
+ //  fRun->SetGenerator(primGen);
+ //  // ------------------------------------------------------------------------
+ 
   
    // Trajectories Visualization (TGeoManager Only)
    // Switch this on if you want to visualize tracks in the
***************
*** 265,282 ****
    fRun->Init();
    // ------------------------------------------------------------------------
    
!   // Set cuts for storing the trajectories.
!   // Switch this on only if trajectories are stored.
!   // Choose this cuts according to your needs, but be aware
!   // that the file size of the output file depends on these cuts
! 
!    FairTrajFilter* trajFilter = FairTrajFilter::Instance();
!    trajFilter->SetStepSizeCut(0.01); // 1 cm
!    trajFilter->SetVertexCut(-2000., -2000., 4., 2000., 2000., 100.);
!    trajFilter->SetMomentumCutP(10e-3); // p_lab > 10 MeV
!    trajFilter->SetEnergyCut(0., 1.02); // 0 < Etot < 1.04 GeV
!    trajFilter->SetStorePrimaries(kTRUE);
!    trajFilter->SetStoreSecondaries(kTRUE);
  
    // -----   Runtime database   ---------------------------------------------
    CbmFieldPar* fieldPar = (CbmFieldPar*) rtdb->getContainer("CbmFieldPar");
--- 291,308 ----
    fRun->Init();
    // ------------------------------------------------------------------------
    
! //  // Set cuts for storing the trajectories.
! //  // Switch this on only if trajectories are stored.
! //  // Choose this cuts according to your needs, but be aware
! //  // that the file size of the output file depends on these cuts
! //
! //   FairTrajFilter* trajFilter = FairTrajFilter::Instance();
! //   trajFilter->SetStepSizeCut(0.01); // 1 cm
! //   trajFilter->SetVertexCut(-2000., -2000., 4., 2000., 2000., 100.);
! //   trajFilter->SetMomentumCutP(10e-3); // p_lab > 10 MeV
! //   trajFilter->SetEnergyCut(0., 1.02); // 0 < Etot < 1.04 GeV
! //   trajFilter->SetStorePrimaries(kTRUE);
! //   trajFilter->SetStoreSecondaries(kTRUE);
  
    // -----   Runtime database   ---------------------------------------------
    CbmFieldPar* fieldPar = (CbmFieldPar*) rtdb->getContainer("CbmFieldPar");
