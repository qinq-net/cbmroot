/* Generated by Together */
#include "CbmPipe.h"

#include "CbmGeoPipe.h"
#include "CbmGeoPassivePar.h"

#include "FairGeoLoader.h"
#include "FairGeoInterface.h"
#include "FairGeoNode.h"
#include "FairRuntimeDb.h"
#include "FairRun.h"

#include "TList.h"
#include "TObjArray.h"

#include "TGeoManager.h"
#include "TFile.h"
#include "TKey.h"


// -----  Default constructor  ------------------------------------------------
CbmPipe::CbmPipe()
  : FairModule(),
  fCombiTrans(),
  fVolumeName("")
{
}
// ----------------------------------------------------------------------------


// -----  Constructor  --------------------------------------------------------
CbmPipe::CbmPipe(const char * name, const char * title)
  : FairModule(name, title),
  fCombiTrans(),
  fVolumeName("")
{
}
// ----------------------------------------------------------------------------


// -----  Destructor  ---------------------------------------------------------
CbmPipe::~CbmPipe()
{
}
// ----------------------------------------------------------------------------


// -----  ConstructGeometry  --------------------------------------------------
void CbmPipe::ConstructGeometry()
{
  TString fileName = GetGeometryFileName();
  if ( fileName.EndsWith(".root") ) {
    LOG(INFO) << "Constructing PIPE geometry from ROOT  file "
              << fileName.Data() << FairLogger::endl;
    ConstructRootGeometry();
  }
  else if ( fileName.EndsWith(".geo") ) {
    LOG(INFO) << "Constructing PIPE geometry from ASCII file "
              << fileName.Data() << FairLogger::endl;
    ConstructAsciiGeometry();
  }
  else
    LOG(FATAL) << "Geometry format of PIPE file " << fileName.Data()
               << " not supported." << FairLogger::endl;
}
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
void CbmPipe::ConstructRootGeometry()
{   
  if( IsNewGeometryFile(fgeoName) ) {
    TGeoVolume *module1 = TGeoVolume::Import(fgeoName, fVolumeName.c_str());
    gGeoManager->GetTopVolume()->AddNode(module1, 0, fCombiTrans);
  } else {
    FairModule::ConstructRootGeometry();
  } 
}   
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
Bool_t CbmPipe::IsNewGeometryFile(TString /*filename*/)
{

  TFile* f=new TFile(fgeoName);
  TList* l = f->GetListOfKeys();
  Int_t numKeys = l->GetSize();
  if ( 2 != numKeys) {
    LOG(INFO) << "Not exactly two keys in the file. File is not of new type."
              << FairLogger::endl;
    return kFALSE;
  }
  TKey* key;
  TIter next( l);
  Bool_t foundGeoVolume = kFALSE;
  Bool_t foundGeoMatrix = kFALSE;
  TGeoTranslation* trans = NULL;
  TGeoRotation* rot = NULL;
  while ((key = (TKey*)next())) {
    if (strcmp(key->GetClassName(),"TGeoVolume") == 0) {
      LOG(INFO) << "Found TGeoVolume in geometry file." << FairLogger::endl;
      LOG(INFO) << "Name: " << key->GetName() << FairLogger::endl;      
      foundGeoVolume =  kTRUE;
      fVolumeName = key->GetName();
      continue;
    }
    if (strcmp(key->GetClassName(),"TGeoVolumeAssembly") == 0) {
      LOG(INFO) << "Found TGeoVolumeAssembly in geometry file." << FairLogger::endl;
      LOG(INFO) << "Name: " << key->GetName() << FairLogger::endl;
      foundGeoVolume =  kTRUE;
      fVolumeName = key->GetName();
      continue;
    }
    if (strcmp(key->GetClassName(),"TGeoTranslation") == 0) {
      LOG(DEBUG) << "Found TGeoTranslation in geometry file." << FairLogger::endl;
      foundGeoMatrix =  kTRUE;
      trans = static_cast<TGeoTranslation*>(key->ReadObj());
      rot = new TGeoRotation();
      fCombiTrans = new TGeoCombiTrans(*trans, *rot);
      continue;
    }
    if (strcmp(key->GetClassName(),"TGeoRotation") == 0) {
      LOG(DEBUG) << "Found TGeoRotation in geometry file." << FairLogger::endl;
      foundGeoMatrix =  kTRUE;
      trans = new TGeoTranslation();
      rot = static_cast<TGeoRotation*>(key->ReadObj());
      fCombiTrans = new TGeoCombiTrans(*trans, *rot);
      continue;
    }
    if (strcmp(key->GetClassName(),"TGeoCombiTrans") == 0) {
      LOG(DEBUG) << "Found TGeoCombiTrans in geometry file." << FairLogger::endl;
      foundGeoMatrix =  kTRUE;
      fCombiTrans = static_cast<TGeoCombiTrans*>(key->ReadObj());
      continue;
    }
  }
  if ( foundGeoVolume && foundGeoMatrix ) {
    LOG(INFO) << "Geometry file is of new type." << FairLogger::endl;
    return kTRUE;
  } else {
    if ( !foundGeoVolume) {
      LOG(INFO) << "No TGeoVolume found in geometry file. File is not of new type."
              << FairLogger::endl;
    }
    if ( !foundGeoVolume) {
      LOG(INFO) << "Not TGeoMatrix derived object found in geometry file. File is not of new type."
                << FairLogger::endl;
    }
    return kFALSE;
  }
}
// ----------------------------------------------------------------------------

// -----  ConstructAsciiGeometry  ---------------------------------------------
void CbmPipe::ConstructAsciiGeometry()
{
        FairGeoLoader *loader=FairGeoLoader::Instance();
	FairGeoInterface *GeoInterface =loader->getGeoInterface();
	CbmGeoPipe *MGeo=new CbmGeoPipe();
	MGeo->setGeomFile(GetGeometryFileName());
	GeoInterface->addGeoModule(MGeo);
	Bool_t rc = GeoInterface->readSet(MGeo);
	if ( rc ) MGeo->create(loader->getGeoBuilder());


        FairGeoNode *volu=MGeo->getVolume("pipevac1");
	if (volu) {
		TList *masterNodes=GeoInterface->getMasterNodes();
      		masterNodes->Add(new FairGeoNode(*volu));
    	}

        TList* volList = MGeo->getListOfVolumes();
        // store geo parameter
        FairRun *fRun = FairRun::Instance();
        FairRuntimeDb *rtdb= FairRun::Instance()->GetRuntimeDb();
        CbmGeoPassivePar* par=(CbmGeoPassivePar*)(rtdb->getContainer("CbmGeoPassivePar"));
        TObjArray *fSensNodes = par->GetGeoSensitiveNodes();
        TObjArray *fPassNodes = par->GetGeoPassiveNodes();

        TListIter iter(volList);
        FairGeoNode* node   = NULL;
        FairGeoVolume *aVol=NULL;

        while( (node = (FairGeoNode*)iter.Next()) ) {
            aVol = dynamic_cast<FairGeoVolume*> ( node );
            if ( node->isSensitive()  ) {
                fSensNodes->AddLast( aVol );
            }else{
                fPassNodes->AddLast( aVol );
            }
        }
	ProcessNodes( volList );
        par->setChanged();
        par->setInputVersion(fRun->GetRunId(),1);
}
// ----------------------------------------------------------------------------
	
ClassImp(CbmPipe)

